{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"note":"","margin":{"childMarginW":10,"childMarginH":5,"marginW":20,"marginH":10},"watermark":"","children":[{"parent":"root","lineStyle":{"lineColor":"#F57F17","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"children":[{"parent":"20c25e0a8bcb","note":"import { unmountComponentAtNode } from &quot;react-dom&quot;;\n\nlet container = null;\nbeforeEach(() =&gt; {\n  // 创建一个 DOM 元素作为渲染目标\n  container = document.createElement(&quot;div&quot;);\n  document.body.appendChild(container);\n});\n\nafterEach(() =&gt; {\n  // 退出时进行清理\n  unmountComponentAtNode(container);\n  container.remove();\n  container = null;\n});","children":[],"id":"f78f08564058","title":"对于每个测试，我们通常希望将&nbsp;React&nbsp;树渲染给附加到&nbsp;document的&nbsp;DOM&nbsp;元素。这点很重要，以便它可以接收&nbsp;DOM&nbsp;事件。当测试结束时，我们需要“清理”并从&nbsp;document&nbsp;中卸载树。<br>常见的方法是使用一对&nbsp;beforeEach&nbsp;和&nbsp;afterEach&nbsp;块，以便它们一直运行，并隔离测试本身造成的影响：","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"20c25e0a8bcb","children":[],"id":"3879dd9b233d","title":"你可以使用不同的测试模式，但请注意，即使测试失败，也需要执行清理。否则，测试可能会导致“泄漏”，并且一个测试可能会影响另一个测试的行为。这使得其难以调试","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"1","text":"&#xe625"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","bold":false,"font-style":"normal","italic":false,"border-radius":"5px","background-color":"#C8E6C9","lineStype":{"lineType":"curve","lineColor":"#F57F17","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#F57F17","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"font-family":"微软雅黑","border-width":"0px","border-style":"none"},"id":"20c25e0a8bcb","title":"创建/清理<br>"},{"parent":"root","lineStyle":{"lineColor":"#FFCDD2","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"children":[{"parent":"4a4e937a1166","note":"act(() =&gt; {\n  // 渲染组件\n});\n// 进行断言","children":[],"id":"26f6456c6af4","title":"在编写&nbsp;UI&nbsp;测试时，可以将渲染、用户事件或数据获取等任务视为与用户界面交互的“单元”。React&nbsp;提供了一个名为&nbsp;act()&nbsp;的&nbsp;helper，它确保在进行任何断言之前，与这些“单元”相关的所有更新都已处理并应用于&nbsp;DOM","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"4a4e937a1166","children":[],"id":"38155145bf86","title":"这有助于使测试运行更接近真实用户在使用应用程序时的体验。这些示例的其余部分使用&nbsp;act()&nbsp;来作出这些保证。<br>你可能会发现直接使用&nbsp;act()&nbsp;有点过于冗长。为了避免一些样板代码，你可以使用&nbsp;React&nbsp;测试库，这些&nbsp;helper&nbsp;是使用&nbsp;act()&nbsp;函数进行封装的","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"1","text":"&#xe625"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","bold":false,"font-style":"normal","italic":false,"border-radius":"5px","background-color":"#FFCDD2","lineStype":{"lineType":"curve","lineColor":"#FFCDD2","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#FFCDD2","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"font-family":"微软雅黑","border-width":"0px","border-style":"none"},"id":"4a4e937a1166","title":"act()"},{"parent":"root","lineStyle":{"lineColor":"#E0E0E0","lineWidth":"2"},"children":[{"parent":"90f72e9b7182","note":"// hello.js\n\nimport React from &quot;react&quot;;\n\nexport default function Hello(props) {\n  if (props.name) {\n    return &lt;h1&gt;你好，{props.name}！&lt;/h1&gt;;\n  } else {\n    return &lt;span&gt;嘿，陌生人&lt;/span&gt;;\n  }\n}","children":[],"id":"b06f894eea5b","title":"通常，你可能希望测试组件对于给定的&nbsp;prop&nbsp;渲染是否正确。此时应考虑实现基于&nbsp;prop&nbsp;渲染消息的简单组件","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"90f72e9b7182","children":[{"parent":"ee780be90c30","note":"// hello.test.js\n\nimport React from &quot;react&quot;;\nimport { render, unmountComponentAtNode } from &quot;react-dom&quot;;\nimport { act } from &quot;react-dom/test-utils&quot;;\n\nimport Hello from &quot;./hello&quot;;\n\nlet container = null;\nbeforeEach(() =&gt; {\n  // 创建一个 DOM 元素作为渲染目标\n  container = document.createElement(&quot;div&quot;);\n  document.body.appendChild(container);\n});\n\nafterEach(() =&gt; {\n  // 退出时进行清理\n  unmountComponentAtNode(container);\n  container.remove();\n  container = null;\n});\n\nit(&quot;渲染有或无名称&quot;, () =&gt; {\n  act(() =&gt; {\n    render(&lt;Hello /&gt;, container);\n  });\n  expect(container.textContent).toBe(&quot;嘿，陌生人&quot;);\n\n  act(() =&gt; {\n    render(&lt;Hello name=&quot;Jenny&quot; /&gt;, container);\n  });\n  expect(container.textContent).toBe(&quot;你好，Jenny！&quot;);\n\n  act(() =&gt; {\n    render(&lt;Hello name=&quot;Margaret&quot; /&gt;, container);\n  });\n  expect(container.textContent).toBe(&quot;你好，Margaret！&quot;);\n});","children":[],"id":"a5ef16260565","title":"代码"}],"id":"ee780be90c30","title":"我们可以为这个组件编写测试：","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"1","text":"&#xe625"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"bold":false,"font-style":"normal","italic":false,"border-radius":"5px","background-color":"#E0E0E0","lineStype":{"lineType":"curve","lineColor":"#FFE0B2","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#E0E0E0","lineWidth":"2"},"font-family":"微软雅黑","border-width":0,"border-style":"solid"},"id":"90f72e9b7182","title":"渲染"},{"parent":"root","lineStyle":{"lineColor":"#BBDEFB","randomLineColor":"rgb(255,204,204)","lineWidth":"2"},"children":[{"parent":"a5fa884e620f","note":"// user.js\n\nimport React, { useState, useEffect } from &quot;react&quot;;\n\nexport default function User(props) {\n  const [user, setUser] = useState(null);\n\n  async function fetchUserData(id) {\n    const response = await fetch(&quot;/&quot; + id);\n    setUser(await response.json());\n  }\n\n  useEffect(() =&gt; {\n    fetchUserData(props.id);\n  }, [props.id]);\n\n  if (!user) {\n    return &quot;加载中...&quot;;\n  }\n\n  return (\n    &lt;details&gt;\n      &lt;summary&gt;{user.name}&lt;/summary&gt;\n      &lt;strong&gt;{user.age}&lt;/strong&gt; 岁\n      &lt;br /&gt;\n      住在 {user.address}\n    &lt;/details&gt;\n  );\n}","children":[],"id":"d3742cff6e16","title":"你可以使用假数据来&nbsp;mock&nbsp;请求，而不是在所有测试中调用真正的&nbsp;API。使用“假”数据&nbsp;mock&nbsp;数据获取可以防止由于后端不可用而导致的测试不稳定，并使它们运行得更快。注意：你可能仍然希望使用一个“端到端”的框架来运行测试子集，该框架可显示整个应用程序是否一起工作","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"a5fa884e620f","children":[{"parent":"bef60e8cb745","note":"// user.test.js\n\nimport React from &quot;react&quot;;\nimport { render, unmountComponentAtNode } from &quot;react-dom&quot;;\nimport { act } from &quot;react-dom/test-utils&quot;;\nimport User from &quot;./user&quot;;\n\nlet container = null;\nbeforeEach(() =&gt; {\n  // 创建一个 DOM 元素作为渲染目标\n  container = document.createElement(&quot;div&quot;);\n  document.body.appendChild(container);\n});\n\nafterEach(() =&gt; {\n  // 退出时进行清理\n  unmountComponentAtNode(container);\n  container.remove();\n  container = null;\n});\n\nit(&quot;渲染用户数据&quot;, async () =&gt; {\n  const fakeUser = {\n    name: &quot;Joni Baez&quot;,\n    age: &quot;32&quot;,\n    address: &quot;123, Charming Avenue&quot;\n  };\n  jest.spyOn(global, &quot;fetch&quot;).mockImplementation(() =&gt;\n    Promise.resolve({\n      json: () =&gt; Promise.resolve(fakeUser)\n    })\n  );\n\n  // 使用异步的 act 应用执行成功的 promise\n  await act(async () =&gt; {\n    render(&lt;User id=&quot;123&quot; /&gt;, container);\n  });\n\n  expect(container.querySelector(&quot;summary&quot;).textContent).toBe(fakeUser.name);\n  expect(container.querySelector(&quot;strong&quot;).textContent).toBe(fakeUser.age);\n  expect(container.textContent).toContain(fakeUser.address);\n\n  // 清理 mock 以确保测试完全隔离\n  global.fetch.mockRestore();\n});","children":[],"id":"045cd51e5dab","title":"代码"}],"id":"bef60e8cb745","title":"我们可以为它编写测试","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"1","text":"&#xe625"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","bold":false,"font-style":"normal","italic":false,"border-radius":"5px","background-color":"#BBDEFB","lineStype":{"lineType":"curve","lineColor":"#BBDEFB","randomLineColor":"rgb(255,204,204)","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#BBDEFB","randomLineColor":"rgb(255,204,204)","lineWidth":"2"},"font-family":"微软雅黑","border-width":"0px","border-style":"none"},"id":"a5fa884e620f","title":"数据获取"},{"parent":"root","lineStyle":{"randomLineColor":"rgb(255,204,204)","lineColor":"#BBDEFB"},"children":[{"parent":"812b3a9306dd","note":"// map.js\n\nimport React from &quot;react&quot;;\n\nimport { LoadScript, GoogleMap } from &quot;react-google-maps&quot;;\nexport default function Map(props) {\n  return (\n    &lt;LoadScript id=&quot;script-loader&quot; googleMapsApiKey=&quot;YOUR_API_KEY&quot;&gt;\n      &lt;GoogleMap id=&quot;example-map&quot; center={props.center} /&gt;\n    &lt;/LoadScript&gt;\n  );\n}\n\n// contact.js\n\nimport React from &quot;react&quot;;\nimport Map from &quot;./map&quot;;\n\nfunction Contact(props) {\n  return (\n    &lt;div&gt;\n      &lt;address&gt;\n        联系 {props.name}，通过{&quot; &quot;}\n        &lt;a data-testid=&quot;email&quot; href={&quot;mailto:&quot; + props.email}&gt;\n          email\n        &lt;/a&gt;\n        或者他们的 &lt;a data-testid=&quot;site&quot; href={props.site}&gt;\n          网站\n        &lt;/a&gt;。\n      &lt;/address&gt;\n      &lt;Map center={props.center} /&gt;\n    &lt;/div&gt;\n  );\n}","children":[],"id":"81d4842d0d98","title":"有些模块可能在测试环境中不能很好地工作，或者对测试本身不是很重要。使用虚拟数据来&nbsp;mock&nbsp;这些模块可以使你为代码编写测试变得更容易。<br>考虑一个嵌入第三方&nbsp;GoogleMap&nbsp;组件的&nbsp;Contact&nbsp;组件","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"812b3a9306dd","note":"// contact.test.js\n\nimport React from &quot;react&quot;;\nimport { render, unmountComponentAtNode } from &quot;react-dom&quot;;\nimport { act } from &quot;react-dom/test-utils&quot;;\n\nimport Contact from &quot;./contact&quot;;\nimport MockedMap from &quot;./map&quot;;\n\njest.mock(&quot;./map&quot;, () =&gt; {\n  return function DummyMap(props) {\n    return (\n      &lt;div data-testid=&quot;map&quot;&gt;\n        {props.center.lat}:{props.center.long}\n      &lt;/div&gt;\n    );\n  };\n});\n\nlet container = null;\nbeforeEach(() =&gt; {\n  // 创建一个 DOM 元素作为渲染目标\n  container = document.createElement(&quot;div&quot;);\n  document.body.appendChild(container);\n});\n\nafterEach(() =&gt; {\n  // 退出时进行清理\n  unmountComponentAtNode(container);\n  container.remove();\n  container = null;\n});\n\nit(&quot;应渲染联系信息&quot;, () =&gt; {\n  const center = { lat: 0, long: 0 };\n  act(() =&gt; {\n    render(\n      &lt;Contact\n        name=&quot;Joni Baez&quot;\n        email=&quot;test@example.com&quot;\n        site=&quot;http://test.com&quot;\n        center={center}\n      /&gt;,\n      container\n    );\n  });\n\n  expect(\n    container.querySelector(&quot;[data-testid=&#39;email&#39;]&quot;).getAttribute(&quot;href&quot;)\n  ).toEqual(&quot;mailto:test@example.com&quot;);\n\n  expect(\n    container.querySelector(&#39;[data-testid=&quot;site&quot;]&#39;).getAttribute(&quot;href&quot;)\n  ).toEqual(&quot;http://test.com&quot;);\n\n  expect(container.querySelector(&#39;[data-testid=&quot;map&quot;]&#39;).textContent).toEqual(\n    &quot;0:0&quot;\n  );\n});","children":[],"id":"0b4b0647241b","title":"如果不想在测试中加载这个组件，我们可以将依赖&nbsp;mock&nbsp;到一个虚拟组件，然后运行我们的测试","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"1","text":"&#xe625"}]}],"style":{"background-color":"#BBDEFB","border-radius":"5px","color":"#212121","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"812b3a9306dd","title":"mock&nbsp;模块<br>"},{"parent":"root","lineStyle":{"lineColor":"#E1BEE7"},"children":[{"parent":"3b7f7da9d693","children":[{"parent":"3d72025d5a72","note":"// toggle.js\n\nimport React, { useState } from &quot;react&quot;;\n\nexport default function Toggle(props) {\n  const [state, setState] = useState(false);\n  return (\n    &lt;button\n      onClick={() =&gt; {\n        setState(previousState =&gt; !previousState);\n        props.onChange(!state);\n      }}\n      data-testid=&quot;toggle&quot;\n    &gt;\n      {state === true ? &quot;Turn off&quot; : &quot;Turn on&quot;}\n    &lt;/button&gt;\n  );\n}","children":[],"id":"5a187bb1ee37","title":"代码"}],"id":"3d72025d5a72","title":"我们建议在&nbsp;DOM&nbsp;元素上触发真正的&nbsp;DOM&nbsp;事件，然后对结果进行断言。考虑一个&nbsp;Toggle&nbsp;组件：","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"3b7f7da9d693","children":[{"parent":"149d68572c42","note":"// toggle.test.js\n\nimport React from &quot;react&quot;;\nimport { render, unmountComponentAtNode } from &quot;react-dom&quot;;\nimport { act } from &quot;react-dom/test-utils&quot;;\n\nimport Toggle from &quot;./toggle&quot;;\n\nlet container = null;\nbeforeEach(() =&gt; {\n  // 创建一个 DOM 元素作为渲染目标\n  container = document.createElement(&quot;div&quot;);\n  // container *必须* 附加到 document，事件才能正常工作。\n  document.body.appendChild(container);\n});\n\nafterEach(() =&gt; {\n  // 退出时进行清理\n  unmountComponentAtNode(container);\n  container.remove();\n  container = null;\n});\n\nit(&quot;点击时更新值&quot;, () =&gt; {\n  const onChange = jest.fn();\n  act(() =&gt; {\n    render(&lt;Toggle onChange={onChange} /&gt;, container);\n  });\n\n  // 获取按钮元素，并触发点击事件\n  const button = document.querySelector(&quot;[data-testid=toggle]&quot;);\n  expect(button.innerHTML).toBe(&quot;Turn on&quot;);\n\n  act(() =&gt; {\n    button.dispatchEvent(new MouseEvent(&quot;click&quot;, { bubbles: true }));\n  });\n\n  expect(onChange).toHaveBeenCalledTimes(1);\n  expect(button.innerHTML).toBe(&quot;Turn off&quot;);\n\n  act(() =&gt; {\n    for (let i = 0; i &lt; 5; i++) {\n      button.dispatchEvent(new MouseEvent(&quot;click&quot;, { bubbles: true }));\n    }\n  });\n\n  expect(onChange).toHaveBeenCalledTimes(6);\n  expect(button.innerHTML).toBe(&quot;Turn on&quot;);\n});","children":[],"id":"2513ae55c3a0","title":"代码"}],"id":"149d68572c42","title":"我们可以为它编写测试","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"1","text":"&#xe625"}]}],"style":{"background-color":"#E1BEE7","border-radius":"5px","color":"#212121","font-weight":"bold","font-size":13},"id":"3b7f7da9d693","title":"Events"},{"parent":"root","lineStyle":{"randomLineColor":"rgb(153,204,255)","lineColor":"#F57F17"},"children":[{"parent":"b653f7534587","note":"// card.js\n\nimport React, { useEffect } from &quot;react&quot;;\n\nexport default function Card(props) {\n  useEffect(() =&gt; {\n    const timeoutID = setTimeout(() =&gt; {\n      props.onSelect(null);\n    }, 5000);\n    return () =&gt; {\n      clearTimeout(timeoutID);\n    };\n  }, [props.onSelect]);\n\n  return [1, 2, 3, 4].map(choice =&gt; (\n    &lt;button\n      key={choice}\n      data-testid={choice}\n      onClick={() =&gt; props.onSelect(choice)}\n    &gt;\n      {choice}\n    &lt;/button&gt;\n  ));","children":[],"id":"06a83c1e3750","title":"你的代码可能会使用基于计时器的函数（如&nbsp;setTimeout）来安排将来更多的工作。在这个例子中，多项选择面板等待选择并前进，如果在&nbsp;5&nbsp;秒内没有做出选择，则超时","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"b653f7534587","note":"// card.test.js\n\nimport React from &quot;react&quot;;\nimport { render, unmountComponentAtNode } from &quot;react-dom&quot;;\nimport { act } from &quot;react-dom/test-utils&quot;;\n\nimport Card from &quot;./card&quot;;\n\njest.useFakeTimers();\n\nlet container = null;\nbeforeEach(() =&gt; {\n  // 创建一个 DOM 元素作为渲染目标\n  container = document.createElement(&quot;div&quot;);\n  document.body.appendChild(container);\n});\n\nafterEach(() =&gt; {\n  // 退出时进行清理\n  unmountComponentAtNode(container);\n  container.remove();\n  container = null;\n});\n\nit(&quot;超时后应选择 null&quot;, () =&gt; {\n  const onSelect = jest.fn();\n  act(() =&gt; {\n    render(&lt;Card onSelect={onSelect} /&gt;, container);\n  });\n\n  // 提前 100 毫秒执行\n  act(() =&gt; {\n    jest.advanceTimersByTime(100);\n  });\n  expect(onSelect).not.toHaveBeenCalled();\n\n  // 然后提前 5 秒执行\n  act(() =&gt; {\n    jest.advanceTimersByTime(5000);\n  });\n  expect(onSelect).toHaveBeenCalledWith(null);\n});\n\nit(&quot;移除时应进行清理&quot;, () =&gt; {\n  const onSelect = jest.fn();\n  act(() =&gt; {\n    render(&lt;Card onSelect={onSelect} /&gt;, container);\n  });\n  act(() =&gt; {\n    jest.advanceTimersByTime(100);\n  });\n  expect(onSelect).not.toHaveBeenCalled();\n\n  // 卸载应用程序\n  act(() =&gt; {\n    render(null, container);\n  });\n  act(() =&gt; {\n    jest.advanceTimersByTime(5000);\n  });\n  expect(onSelect).not.toHaveBeenCalled();\n});\n\nit(&quot;应接受选择&quot;, () =&gt; {\n  const onSelect = jest.fn();\n  act(() =&gt; {\n    render(&lt;Card onSelect={onSelect} /&gt;, container);\n  });\n\n  act(() =&gt; {\n    container\n      .querySelector(&quot;[data-testid=&#39;2&#39;]&quot;)\n      .dispatchEvent(new MouseEvent(&quot;click&quot;, { bubbles: true }));\n  });\n\n  expect(onSelect).toHaveBeenCalledWith(2);\n});","children":[],"id":"fe34edd8c073","title":"我们可以利用&nbsp;Jest&nbsp;的计时器&nbsp;mock&nbsp;为这个组件编写测试，并测试它可能处于的不同状态","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"1","text":"&#xe625"}]}],"style":{"background-color":"#C8E6C9","border-radius":"5px","color":"#212121","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"b653f7534587","title":"计时器"},{"parent":"root","lineStyle":{"lineColor":"#FFE0B2"},"children":[{"parent":"2c0b8a719934","note":"// hello.test.js, again\n\nimport React from &quot;react&quot;;\nimport { render, unmountComponentAtNode } from &quot;react-dom&quot;;\nimport { act } from &quot;react-dom/test-utils&quot;;\nimport pretty from &quot;pretty&quot;;\n\nimport Hello from &quot;./hello&quot;;\n\nlet container = null;\nbeforeEach(() =&gt; {\n  // 创建一个 DOM 元素作为渲染目标\n  container = document.createElement(&quot;div&quot;);\n  document.body.appendChild(container);\n});\n\nafterEach(() =&gt; {\n  // 退出时进行清理\n  unmountComponentAtNode(container);\n  container.remove();\n  container = null;\n});\n\nit(&quot;应渲染问候语&quot;, () =&gt; {\n  act(() =&gt; {\n    render(&lt;Hello /&gt;, container);\n  });\n\n  expect(\n    pretty(container.innerHTML)\n  ).toMatchInlineSnapshot(); /* ... 由 jest 自动填充 ... */\n\n  act(() =&gt; {\n    render(&lt;Hello name=&quot;Jenny&quot; /&gt;, container);\n  });\n\n  expect(\n    pretty(container.innerHTML)\n  ).toMatchInlineSnapshot(); /* ... 由 jest 自动填充 ... */\n\n  act(() =&gt; {\n    render(&lt;Hello name=&quot;Margaret&quot; /&gt;, container);\n  });\n\n  expect(\n    pretty(container.innerHTML)\n  ).toMatchInlineSnapshot(); /* ... 由 jest 自动填充 ... */\n});","children":[],"id":"0d17e125fc4e","title":"像&nbsp;Jest&nbsp;这样的框架还允许你使用&nbsp;toMatchSnapshot&nbsp;/&nbsp;toMatchInlineSnapshot&nbsp;保存数据的“快照”。有了这些，我们可以“保存”渲染的组件输出，并确保对它的更新作为对快照的更新显式提交。<br>在这个示例中，我们渲染一个组件并使用&nbsp;pretty&nbsp;包对渲染的&nbsp;HTML&nbsp;进行格式化，然后将其保存为内联快照","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"2c0b8a719934","children":[],"id":"419628db349c","title":"通常，进行具体的断言比使用快照更好。这类测试包括实现细节，因此很容易中断，并且团队可能对快照中断不敏感。选择性地&nbsp;mock&nbsp;一些子组件可以帮助减小快照的大小，并使它们在代码评审中保持可读性","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"1","text":"&#xe625"}]}],"style":{"background-color":"#FFE0B2","border-radius":"5px","color":"#212121","font-weight":"bold","font-size":13},"id":"2c0b8a719934","title":"快照测试<br>"},{"parent":"root","lineStyle":{"lineColor":"#FFCDD2","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"children":[{"parent":"f7804ebc5beb","note":"import { act as domAct } from &quot;react-dom/test-utils&quot;;\nimport { act as testAct, create } from &quot;react-test-renderer&quot;;\n// ...\nlet root;\ndomAct(() =&gt; {\n  testAct(() =&gt; {\n    root = create(&lt;App /&gt;);\n  });\n});\nexpect(root).toMatchSnapshot();","children":[],"id":"a48cbf0f1919","title":"在极少数情况下，你可能正在使用多个渲染器的组件上运行测试。例如，你可能正在使用&nbsp;react-test-renderer&nbsp;组件上运行快照测试，该组件内部使用子组件内部的&nbsp;ReactDOM.render&nbsp;渲染一些内容。在这个场景中，你可以使用与它们的渲染器相对应的&nbsp;act()&nbsp;来包装更新。","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","bold":false,"font-style":"normal","italic":false,"border-radius":"5px","background-color":"#FFCDD2","lineStype":{"lineType":"curve","lineColor":"#FFCDD2","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#FFCDD2","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"font-family":"微软雅黑","border-width":"0px","border-style":"none"},"id":"f7804ebc5beb","title":"多渲染器"}],"root":true,"theme":"customise_7fd055efa78b","style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","font-weight":"bold","font-size":15,"border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"root","title":"测试技巧","icons":[{"color":"rgb(255, 255, 255)","name":"","index":"46","text":"&#xe693"}],"structure":"mind_right"}},"meta":{"exportTime":"2022-04-10 23:48:31","member":"60cca488e0b34d55bbf2954f","diagramInfo":{"creator":"60cca488e0b34d55bbf2954f","created":"2022-04-10 23:39:55","modified":"2022-04-10 23:48:23","title":"6.2测试技巧","category":"mind_free"},"id":"6252fa4b1e085332f338e9ff","type":"ProcessOn Schema File","version":"1.0"}}