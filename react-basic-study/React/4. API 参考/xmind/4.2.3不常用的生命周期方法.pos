{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"note":"","watermark":"","children":[{"parent":"root","lineStyle":{"lineColor":"#BBDEFB"},"children":[{"parent":"812b3a9306dd","note":"","children":[],"id":"ac25a09c6779","title":"shouldComponentUpdate(nextProps,&nbsp;nextState)<br>","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"812b3a9306dd","children":[],"id":"4d70d73dad33","title":"根据&nbsp;shouldComponentUpdate()&nbsp;的返回值，判断&nbsp;React&nbsp;组件的输出是否受当前&nbsp;state&nbsp;或&nbsp;props&nbsp;更改的影响。默认行为是&nbsp;state&nbsp;每次发生变化组件都会重新渲染。大部分情况下，你应该遵循默认行为。<br>当&nbsp;props&nbsp;或&nbsp;state&nbsp;发生变化时，shouldComponentUpdate()&nbsp;会在渲染执行之前被调用。返回值默认为&nbsp;true。首次渲染或使用&nbsp;forceUpdate()&nbsp;时不会调用该方法<br>","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"812b3a9306dd","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[],"style":{"lineStype":{"lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","font-style":"normal"},"id":"06421878cf25","title":"此方法仅作为性能优化的方式而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生&nbsp;bug。你应该考虑使用内置的&nbsp;PureComponent&nbsp;组件，而不是手动编写&nbsp;shouldComponentUpdate()。PureComponent&nbsp;会对&nbsp;props&nbsp;和&nbsp;state&nbsp;进行浅层比较，并减少了跳过必要更新的可能性。<br>如果你一定要手动编写此函数，可以将&nbsp;this.props&nbsp;与&nbsp;nextProps&nbsp;以及&nbsp;this.state&nbsp;与nextState&nbsp;进行比较，并返回&nbsp;false&nbsp;以告知&nbsp;React&nbsp;可以跳过更新。请注意，返回&nbsp;false&nbsp;并不会阻止子组件在&nbsp;state&nbsp;更改时重新渲染。<br>我们不建议在&nbsp;shouldComponentUpdate()&nbsp;中进行深层比较或使用&nbsp;JSON.stringify()。这样非常影响效率，且会损害性能。<br>目前，如果&nbsp;shouldComponentUpdate()&nbsp;返回&nbsp;false，则不会调用&nbsp;UNSAFE_componentWillUpdate()，render()&nbsp;和&nbsp;componentDidUpdate()。后续版本，React&nbsp;可能会将&nbsp;shouldComponentUpdate&nbsp;视为提示而不是严格的指令，并且，当返回&nbsp;false&nbsp;时，仍可能导致组件重新渲染","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"2","text":"&#xe62a"}]}],"style":{"background-color":"#BBDEFB","border-radius":"5px","color":"#212121","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"812b3a9306dd","title":"shouldComponentUpdate()<br>"},{"parent":"root","lineStyle":{"lineColor":"#E1BEE7","lineWidth":"2"},"children":[{"parent":"896498dd7718","note":"","children":[],"id":"3c25c1c2ba10","title":"static&nbsp;getDerivedStateFromProps(props,&nbsp;state)","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"896498dd7718","children":[],"id":"4be7280572a9","title":"getDerivedStateFromProps&nbsp;会在调用&nbsp;render&nbsp;方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新&nbsp;state，如果返回&nbsp;null&nbsp;则不更新任何内容。<br>此方法适用于罕见的用例，即&nbsp;state&nbsp;的值在任何时候都取决于&nbsp;props。例如，实现&nbsp;&lt;Transition&gt;&nbsp;组件可能很方便，该组件会比较当前组件与下一组件，以决定针对哪些组件进行转场动画。<br>","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"896498dd7718","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[],"style":{"lineStype":{"lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","font-style":"normal"},"id":"d7a2018a01ad","title":"此方法无权访问组件实例。如果你需要，可以通过提取组件&nbsp;props&nbsp;的纯函数及&nbsp;class&nbsp;之外的状态，在getDerivedStateFromProps()和其他&nbsp;class&nbsp;方法之间重用代码。<br>请注意，不管原因是什么，都会在每次渲染前触发此方法。这与&nbsp;UNSAFE_componentWillReceiveProps&nbsp;形成对比，后者仅在父组件重新渲染时触发，而不是在内部调用&nbsp;setState&nbsp;时","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"2","text":"&#xe62a"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"font-style":"normal","border-radius":"5px","background-color":"#E1BEE7","lineStype":{"lineColor":"#E1BEE7","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#E1BEE7","lineWidth":"2"},"font-family":"微软雅黑","border-width":0,"border-style":"solid"},"id":"896498dd7718","title":"static&nbsp;getDerivedStateFromProps()<br>"},{"parent":"root","lineStyle":{"lineColor":"#FFCDD2","lineWidth":"2"},"children":[{"parent":"5bf8fe5c3c71","note":"","children":[],"id":"4b0af9a73e1a","title":"getSnapshotBeforeUpdate()&nbsp;在最近一次渲染输出（提交到&nbsp;DOM&nbsp;节点）之前调用。它使得组件能在发生更改之前从&nbsp;DOM&nbsp;中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给&nbsp;componentDidUpdate()","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","font-style":"normal","border-radius":"5px","background-color":"#FFCDD2","lineStype":{"lineColor":"#FFCDD2","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#FFCDD2","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"font-family":"微软雅黑","border-width":"0px","border-style":"none"},"id":"5bf8fe5c3c71","title":"getSnapshotBeforeUpdate()<br>"},{"parent":"root","lineStyle":{"lineColor":"#C8E6C9","lineWidth":"2"},"children":[{"parent":"a01eafed5bb9","note":"","children":[],"id":"15028f67c0e5","title":"Error&nbsp;boundaries&nbsp;是&nbsp;React&nbsp;组件，它会在其子组件树中的任何位置捕获&nbsp;JavaScript&nbsp;错误，并记录这些错误，展示降级&nbsp;UI&nbsp;而不是崩溃的组件树。Error&nbsp;boundaries&nbsp;组件会捕获在渲染期间，在生命周期方法以及其整个树的构造函数中发生的错误","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"a01eafed5bb9","children":[],"id":"412c765359ca","title":"如果&nbsp;class&nbsp;组件定义了生命周期方法&nbsp;static&nbsp;getDerivedStateFromError()&nbsp;或&nbsp;componentDidCatch()&nbsp;中的任何一个（或两者），它就成为了&nbsp;Error&nbsp;boundaries。通过生命周期更新&nbsp;state&nbsp;可让组件捕获树中未处理的&nbsp;JavaScript&nbsp;错误并展示降级&nbsp;UI。<br>仅使用&nbsp;Error&nbsp;boundaries&nbsp;组件来从意外异常中恢复的情况；不要将它们用于流程控制<br>","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","font-style":"normal","border-radius":"5px","background-color":"#C8E6C9","lineStype":{"lineColor":"#F57F17","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#C8E6C9","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"font-family":"微软雅黑","border-width":"0px","border-style":"none"},"id":"a01eafed5bb9","title":"Error&nbsp;boundaries<br>"},{"parent":"root","lineStyle":{"lineColor":"#FFE0B2","lineWidth":"2"},"children":[{"parent":"cecb23f7996e","note":"","children":[],"id":"10eb40fe09d6","title":"此生命周期会在后代组件抛出错误后被调用。&nbsp;它将抛出的错误作为参数，并返回一个值以更新&nbsp;state","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"cecb23f7996e","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[{"parent":"9e830d23e729","children":[],"id":"4405c98e63db","title":"getDerivedStateFromError()&nbsp;会在渲染阶段调用，因此不允许出现副作用。&nbsp;如遇此类情况，请改用&nbsp;componentDidCatch()"}],"style":{"lineStype":{"lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","font-style":"normal"},"id":"9e830d23e729","title":"注意<br>","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"font-style":"normal","border-radius":"5px","background-color":"#FFE0B2","lineStype":{"lineColor":"#FFE0B2","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#FFE0B2","lineWidth":"2"},"font-family":"微软雅黑","border-width":0,"border-style":"solid"},"id":"cecb23f7996e","title":"static&nbsp;getDerivedStateFromError()<br>"},{"parent":"root","children":[{"parent":"3d33b597f14e","children":[{"parent":"8cb9bccb57c1","children":[],"id":"6ca7758ddb64","title":"error&nbsp;——&nbsp;抛出的错误。<br>info&nbsp;——&nbsp;带有&nbsp;componentStack&nbsp;key&nbsp;的对象，其中包含有关组件引发错误的栈信息"}],"id":"8cb9bccb57c1","title":"此生命周期在后代组件抛出错误后被调用。&nbsp;它接收两个参数"},{"parent":"3d33b597f14e","children":[],"id":"4de6f712e237","title":"componentDidCatch()&nbsp;会在“提交”阶段被调用，因此允许执行副作用。&nbsp;它应该用于记录错误之类的情况"}],"style":{"font-weight":"bold","font-size":13},"id":"3d33b597f14e","title":"componentDidCatch()"}],"root":true,"theme":"customise_7fd055efa78b","style":{"background-color":"#2196F3","border-radius":"6px","color":"rgb(255, 255, 255)","font-weight":"bold","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"root","title":"不常用的生命周期方法","icons":[],"structure":"mind_free"}},"meta":{"exportTime":"2022-04-09 12:08:24","member":"60cca488e0b34d55bbf2954f","diagramInfo":{"creator":"60cca488e0b34d55bbf2954f","created":"2022-04-09 11:53:26","modified":"2022-04-09 12:08:13","title":"4.2.3不常用的生命周期方法","category":"mind_free"},"id":"625103365653bb0743cab5d7","type":"ProcessOn Schema File","version":"1.0"}}