{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"note":"","margin":{"childMarginW":10,"childMarginH":5,"marginW":20,"marginH":10},"watermark":"","children":[{"parent":"root","lineStyle":{"lineColor":"#F57F17","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"children":[{"parent":"20c25e0a8bcb","children":[],"id":"f78f08564058","title":"Effect&nbsp;Hook&nbsp;可以让你在函数组件中执行副作用操作","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"20c25e0a8bcb","children":[{"parent":"3879dd9b233d","note":"import React, { useState, useEffect } from &#39;react&#39;;\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  // Similar to componentDidMount and componentDidUpdate:\n  useEffect(() =&gt; {\n    // Update the document title using the browser API\n    document.title = `You clicked ${count} times`;\n  });\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;You clicked {count} times&lt;/p&gt;\n      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;\n        Click me\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n这段代码基于上一章节中的计数器示例进行修改，我们为计数器增加了一个小功能：将 document 的 title 设置为包含了点击次数的消息。","children":[],"id":"3590c235fce6","title":"代码"}],"id":"3879dd9b233d","title":"例子","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"20c25e0a8bcb","children":[],"id":"9ad2ebdb547a","title":"数据获取，设置订阅以及手动更改&nbsp;React&nbsp;组件中的&nbsp;DOM&nbsp;都属于副作用<br>在&nbsp;React&nbsp;组件中有两种常见副作用操作：需要清除的和不需要清除的<br>","icons":[{"color":"rgb(48, 191, 191)","name":"priority","index":"2","text":"&#xe62a"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","bold":false,"font-style":"normal","italic":false,"border-radius":"5px","background-color":"#C8E6C9","lineStype":{"lineType":"curve","lineColor":"#F57F17","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#F57F17","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"font-family":"微软雅黑","border-width":"0px","border-style":"none"},"id":"20c25e0a8bcb","title":"介绍<br>"},{"parent":"root","lineStyle":{"lineColor":"#FFCDD2","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"children":[{"parent":"4a4e937a1166","children":[],"id":"26f6456c6af4","title":"有时候，我们只想在&nbsp;React&nbsp;更新&nbsp;DOM&nbsp;之后运行一些额外的代码。比如发送网络请求，手动变更&nbsp;DOM，记录日志，这些都是常见的无需清除的操作。因为我们在执行完这些操作之后，就可以忽略他们了。","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"4a4e937a1166","children":[{"parent":"38155145bf86","note":"class Example extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  componentDidMount() {\n    document.title = `You clicked ${this.state.count} times`;\n  }\n  componentDidUpdate() {\n    document.title = `You clicked ${this.state.count} times`;\n  }\n\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt;\n        &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt;\n          Click me\n        &lt;/button&gt;\n      &lt;/div&gt;\n    );\n  }\n}","children":[{"parent":"13d4e6e343d7","children":[],"id":"0998840fc916","title":"在&nbsp;React&nbsp;的&nbsp;class&nbsp;组件中，render&nbsp;函数是不应该有任何副作用的。<br>一般来说，在这里执行操作太早了，我们基本上都希望在&nbsp;React&nbsp;更新&nbsp;DOM&nbsp;之后才执行我们的操作。<br>这就是为什么在&nbsp;React&nbsp;class&nbsp;中，我们把副作用操作放到&nbsp;componentDidMount&nbsp;和&nbsp;componentDidUpdate&nbsp;函数中。<br>回到示例中，这是一个&nbsp;React&nbsp;计数器的&nbsp;class&nbsp;组件。它在&nbsp;React&nbsp;对&nbsp;DOM&nbsp;进行操作之后，立即更新了&nbsp;document&nbsp;的&nbsp;title&nbsp;属性"},{"parent":"13d4e6e343d7","children":[],"id":"895c2c9fbf31","title":"注意，在这个&nbsp;class&nbsp;中，我们需要在两个生命周期函数中编写重复的代码。<br>这是因为很多情况下，我们希望在组件加载和更新时执行同样的操作。从概念上说，我们希望它在每次渲染之后执行&nbsp;——&nbsp;<br>但&nbsp;React&nbsp;的&nbsp;class&nbsp;组件没有提供这样的方法。即使我们提取出一个方法，我们还是要在两个地方调用它"}],"id":"13d4e6e343d7","title":"使用&nbsp;class&nbsp;的示例"},{"parent":"38155145bf86","note":"import React, { useState, useEffect } from &#39;react&#39;;\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() =&gt; {\n    document.title = `You clicked ${count} times`;\n  });\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;You clicked {count} times&lt;/p&gt;\n      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;\n        Click me\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n}","children":[{"parent":"0c14feab269e","children":[{"parent":"8b37228322a2","children":[],"id":"7fda52c73893","title":"通过使用这个&nbsp;Hook，你可以告诉&nbsp;React&nbsp;组件需要在渲染后执行某些操作。React&nbsp;会保存你传递的函数，并且在执行&nbsp;DOM&nbsp;更新之后调用它"}],"id":"8b37228322a2","title":"useEffect&nbsp;做了什么？"},{"parent":"0c14feab269e","children":[{"parent":"20d8a017918d","children":[],"id":"b81a4d51f3d2","title":"将&nbsp;useEffect&nbsp;放在组件内部让我们可以在&nbsp;effect&nbsp;中直接访问&nbsp;count&nbsp;state&nbsp;变量（或其他&nbsp;props）"}],"id":"20d8a017918d","title":"为什么在组件内部调用&nbsp;useEffect？"},{"parent":"0c14feab269e","children":[{"parent":"cc38b3a4bf69","children":[],"id":"abedf8b9c666","title":"是的，默认情况下，它在第一次渲染之后和每次更新之后都会执行"}],"id":"cc38b3a4bf69","title":"useEffect&nbsp;会在每次渲染后都执行吗？"}],"id":"0c14feab269e","title":"使用&nbsp;Hook&nbsp;的示例"}],"id":"38155145bf86","title":"让我们对比一下<br>使用&nbsp;class&nbsp;和&nbsp;Hook&nbsp;<br>都是怎么实现这些副作用的","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"1","text":"&#xe625"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","bold":false,"font-style":"normal","italic":false,"border-radius":"5px","background-color":"#FFCDD2","lineStype":{"lineType":"curve","lineColor":"#FFCDD2","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#FFCDD2","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"font-family":"微软雅黑","border-width":"0px","border-style":"none"},"id":"4a4e937a1166","title":"无需清除的&nbsp;effect"},{"parent":"root","lineStyle":{"lineColor":"#E0E0E0","lineWidth":"2"},"children":[{"parent":"90f72e9b7182","children":[],"id":"b06f894eea5b","title":"有一些副作用是需要清除的。例如订阅外部数据源。这种情况下，清除工作是非常重要的，可以防止引起内存泄露！","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"90f72e9b7182","children":[{"parent":"ee780be90c30","children":[{"parent":"8627ba1dd140","children":[],"id":"81535d069683","title":"在&nbsp;React&nbsp;class&nbsp;中，你通常会在&nbsp;componentDidMount&nbsp;中设置订阅，并在&nbsp;componentWillUnmount&nbsp;中清除它。例如，假设我们有一个&nbsp;ChatAPI&nbsp;模块，它允许我们订阅好友的在线状态。以下是我们如何使用&nbsp;class&nbsp;订阅和显示该状态"},{"parent":"8627ba1dd140","note":"class FriendStatus extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { isOnline: null };\n    this.handleStatusChange = this.handleStatusChange.bind(this);\n  }\n\n  componentDidMount() {\n    ChatAPI.subscribeToFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n  componentWillUnmount() {\n    ChatAPI.unsubscribeFromFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n  handleStatusChange(status) {\n    this.setState({\n      isOnline: status.isOnline\n    });\n  }\n\n  render() {\n    if (this.state.isOnline === null) {\n      return &#39;Loading...&#39;;\n    }\n    return this.state.isOnline ? &#39;Online&#39; : &#39;Offline&#39;;\n  }\n}","children":[],"id":"eadd03c8e941","title":"代码"},{"parent":"8627ba1dd140","children":[],"id":"ca2750e89f3f","title":"你会注意到&nbsp;componentDidMount&nbsp;和&nbsp;componentWillUnmount&nbsp;之间相互对应。使用生命周期函数迫使我们拆分这些逻辑代码，即使这两部分代码都作用于相同的副作用"}],"id":"8627ba1dd140","title":"使用&nbsp;Class&nbsp;的示例"},{"parent":"ee780be90c30","children":[{"parent":"54db83d5a77d","children":[],"id":"1e00dab46159","title":"你可能认为需要单独的&nbsp;effect&nbsp;来执行清除操作。但由于添加和删除订阅的代码的紧密性，所以&nbsp;useEffect&nbsp;的设计是在同一个地方执行。如果你的&nbsp;effect&nbsp;返回一个函数，React&nbsp;将会在执行清除操作时调用它"},{"parent":"54db83d5a77d","note":"import React, { useState, useEffect } from &#39;react&#39;;\n\nfunction FriendStatus(props) {\n  const [isOnline, setIsOnline] = useState(null);\n\n  useEffect(() =&gt; {\n    function handleStatusChange(status) {\n      setIsOnline(status.isOnline);\n    }\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    // Specify how to clean up after this effect:\n    return function cleanup() {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n  });\n\n  if (isOnline === null) {\n    return &#39;Loading...&#39;;\n  }\n  return isOnline ? &#39;Online&#39; : &#39;Offline&#39;;\n}","children":[],"id":"7d0a57a8d84b","title":"代码"},{"parent":"54db83d5a77d","children":[{"parent":"1f94f5de5f08","children":[],"id":"ff4eb5afbad5","title":"这是&nbsp;effect&nbsp;可选的清除机制。每个&nbsp;effect&nbsp;都可以返回一个清除函数"}],"id":"1f94f5de5f08","title":"为什么要在&nbsp;effect&nbsp;中返回一个函数？"},{"parent":"54db83d5a77d","children":[{"parent":"3bdd11cb64a6","children":[],"id":"6610a63cd09f","title":"React&nbsp;会在组件卸载的时候执行清除操作"}],"id":"3bdd11cb64a6","title":"React&nbsp;何时清除&nbsp;effect？"}],"id":"54db83d5a77d","title":"使用&nbsp;Hook&nbsp;的示例"}],"id":"ee780be90c30","title":"现在让我们来比较一下<br>如何用&nbsp;Class&nbsp;和&nbsp;Hook&nbsp;来实现","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"1","text":"&#xe625"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"bold":false,"font-style":"normal","italic":false,"border-radius":"5px","background-color":"#E0E0E0","lineStype":{"lineType":"curve","lineColor":"#FFE0B2","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#E0E0E0","lineWidth":"2"},"font-family":"微软雅黑","border-width":0,"border-style":"solid"},"id":"90f72e9b7182","title":"需要清除的&nbsp;effect"},{"parent":"root","lineStyle":{"randomLineColor":"rgb(255,204,204)","lineColor":"#BBDEFB"},"children":[{"parent":"812b3a9306dd","children":[],"id":"81d4842d0d98","title":"了解了&nbsp;useEffect&nbsp;可以在组件渲染后实现各种不同的副作用。有些副作用可能需要清除，所以需要返回一个函数","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"812b3a9306dd","children":[],"id":"0b4b0647241b","title":"其他的&nbsp;effect&nbsp;可能不必清除，所以不需要返回","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"812b3a9306dd","children":[],"id":"c7a801273750","title":"effect&nbsp;Hook&nbsp;使用同一个&nbsp;API&nbsp;来满足这两种情况","icons":[{"color":"rgb(48, 191, 191)","name":"priority","index":"2","text":"&#xe62a"}]}],"style":{"background-color":"#BBDEFB","border-radius":"5px","color":"#212121","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"812b3a9306dd","title":"小结<br>"},{"parent":"root","lineStyle":{"lineColor":"#E1BEE7"},"children":[{"parent":"3b7f7da9d693","children":[],"id":"3d72025d5a72","title":"使用多个&nbsp;Effect&nbsp;实现关注点分离","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"3b7f7da9d693","children":[],"id":"c79ce255c680","title":"每次更新的时候都要运行&nbsp;Effect","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"3b7f7da9d693","children":[],"id":"531cad0d183f","title":"通过跳过&nbsp;Effect&nbsp;进行性能优化","icons":[{"color":"rgb(48, 191, 191)","name":"priority","index":"2","text":"&#xe62a"}]}],"style":{"background-color":"#E1BEE7","border-radius":"5px","color":"#212121","font-weight":"bold","font-size":13},"id":"3b7f7da9d693","title":"使用&nbsp;Effect&nbsp;的提示"}],"root":true,"theme":"customise_7fd055efa78b","style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","font-weight":"bold","font-size":15,"border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"root","title":"使用&nbsp;Effect&nbsp;Hook","icons":[{"color":"rgb(255, 255, 255)","name":"","index":"52"}],"structure":"mind_right"}},"meta":{"exportTime":"2022-04-10 22:34:41","member":"60cca488e0b34d55bbf2954f","diagramInfo":{"creator":"60cca488e0b34d55bbf2954f","created":"2022-04-10 22:21:09","modified":"2022-04-10 22:34:26","title":"5.4使用 Effect Hook","category":"mind_free"},"id":"6252e7d51efad407891d86d0","type":"ProcessOn Schema File","version":"1.0"}}