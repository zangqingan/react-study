{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"note":"","margin":{"childMarginW":10,"childMarginH":5,"marginW":20,"marginH":10},"watermark":"","children":[{"parent":"root","lineStyle":{"lineColor":"#F57F17","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"children":[{"parent":"20c25e0a8bcb","children":[{"parent":"f78f08564058","children":[],"id":"3599cf313dd5","title":"constructor：函数组件不需要构造函数。你可以通过调用&nbsp;useState&nbsp;来初始化&nbsp;state。如果计算的代价比较昂贵，你可以传一个函数给&nbsp;useState。"},{"parent":"f78f08564058","children":[],"id":"3a1e49744806","title":"getDerivedStateFromProps：改为&nbsp;在渲染时&nbsp;安排一次更新。"},{"parent":"f78f08564058","children":[],"id":"2de584fa9a66","title":"shouldComponentUpdate：详见&nbsp;下方&nbsp;React.memo."},{"parent":"f78f08564058","children":[],"id":"7c145ad8d2b5","title":"render：这是函数组件体本身。"},{"parent":"f78f08564058","children":[],"id":"6c0b28515718","title":"componentDidMount,&nbsp;componentDidUpdate,&nbsp;componentWillUnmount：useEffect&nbsp;Hook&nbsp;可以表达所有这些(包括&nbsp;不那么&nbsp;常见&nbsp;的场景)的组合。"},{"parent":"f78f08564058","children":[],"id":"d7b93f4e3246","title":"getSnapshotBeforeUpdate，componentDidCatch&nbsp;以及&nbsp;getDerivedStateFromError：目前还没有这些方法的&nbsp;Hook&nbsp;等价写法，但很快会被添加。"}],"id":"f78f08564058","title":"生命周期方法<br>要如何对应到<br>&nbsp;Hook？","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"20c25e0a8bcb","children":[{"parent":"3879dd9b233d","children":[],"id":"e308ad8dba5a","title":"有！useRef()&nbsp;Hook&nbsp;不仅可以用于&nbsp;DOM&nbsp;refs。「ref」&nbsp;对象是一个&nbsp;current&nbsp;属性可变且可以容纳任意值的通用容器，类似于一个&nbsp;class&nbsp;的实例属性"}],"id":"3879dd9b233d","title":"有类似实例变量的东西吗？","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"20c25e0a8bcb","children":[{"parent":"9ad2ebdb547a","children":[],"id":"4c25f187bbdf","title":"如果你之前用过&nbsp;class，你或许会试图总是在一次&nbsp;useState()&nbsp;调用中传入一个包含了所有&nbsp;state&nbsp;的对象。如果你愿意的话你可以这么做"}],"id":"9ad2ebdb547a","title":"我应该使用单个还是多个&nbsp;state&nbsp;变量？","icons":[{"color":"rgb(48, 191, 191)","name":"priority","index":"2","text":"&#xe62a"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","bold":false,"font-style":"normal","italic":false,"border-radius":"5px","background-color":"#C8E6C9","lineStype":{"lineType":"curve","lineColor":"#F57F17","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#F57F17","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"font-family":"微软雅黑","border-width":"0px","border-style":"none"},"id":"20c25e0a8bcb","title":"一<br>"},{"parent":"root","lineStyle":{"lineColor":"#FFCDD2","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"children":[{"parent":"4a4e937a1166","children":[{"parent":"26f6456c6af4","children":[],"id":"c8d75eac3b3e","title":"这是个比较罕见的使用场景。如果你需要的话，你可以&nbsp;使用一个可变的&nbsp;ref&nbsp;手动存储一个布尔值来表示是首次渲染还是后续渲染，然后在你的&nbsp;effect&nbsp;中检查这个标识。（如果你发现自己经常在这么做，你可以为之创建一个自定义&nbsp;Hook。）\n\n"}],"id":"26f6456c6af4","title":"我可以只在更新时运行&nbsp;effect&nbsp;吗？","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"4a4e937a1166","children":[{"parent":"38155145bf86","children":[],"id":"15acbe824c02","title":"目前，你可以&nbsp;通过&nbsp;ref&nbsp;来手动实现"}],"id":"38155145bf86","title":"如何获取上一轮的&nbsp;props&nbsp;或&nbsp;state？","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"4a4e937a1166","children":[{"parent":"b91414026afa","children":[],"id":"86246f0a3f45","title":"如果前后两次的值相同，useState&nbsp;和&nbsp;useReducer&nbsp;Hook&nbsp;都会放弃更新。原地修改&nbsp;state&nbsp;并调用&nbsp;setState&nbsp;不会引起重新渲染。<br>通常，你不应该在&nbsp;React&nbsp;中修改本地&nbsp;state。然而，作为一条出路，你可以用一个增长的计数器来在&nbsp;state&nbsp;没变的时候依然强制一次重新渲染"}],"id":"b91414026afa","title":"有类似&nbsp;forceUpdate&nbsp;的东西吗？<br>","icons":[{"color":"rgb(48, 191, 191)","name":"priority","index":"2","text":"&#xe62a"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","bold":false,"font-style":"normal","italic":false,"border-radius":"5px","background-color":"#FFCDD2","lineStype":{"lineType":"curve","lineColor":"#FFCDD2","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#FFCDD2","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"font-family":"微软雅黑","border-width":"0px","border-style":"none"},"id":"4a4e937a1166","title":"二"},{"parent":"root","lineStyle":{"lineColor":"#BBDEFB","randomLineColor":"rgb(255,204,204)","lineWidth":"2"},"children":[{"parent":"a5fa884e620f","children":[{"parent":"d3742cff6e16","children":[],"id":"32653698ed53","title":"尽管你不应该经常需要这么做，但你可以通过&nbsp;useImperativeHandle&nbsp;Hook&nbsp;暴露一些命令式的方法给父组件"}],"id":"d3742cff6e16","title":"我可以引用一个函数组件吗？","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"a5fa884e620f","children":[{"parent":"bef60e8cb745","children":[],"id":"a15d6c1b404c","title":"获取&nbsp;DOM&nbsp;节点的位置或是大小的基本方式是使用&nbsp;callback&nbsp;ref。每当&nbsp;ref&nbsp;被附加到一个另一个节点，React&nbsp;就会调用&nbsp;callback"}],"id":"bef60e8cb745","title":"我该如何测量&nbsp;DOM&nbsp;节点？","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"1","text":"&#xe625"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","bold":false,"font-style":"normal","italic":false,"border-radius":"5px","background-color":"#BBDEFB","lineStype":{"lineType":"curve","lineColor":"#BBDEFB","randomLineColor":"rgb(255,204,204)","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#BBDEFB","randomLineColor":"rgb(255,204,204)","lineWidth":"2"},"font-family":"微软雅黑","border-width":"0px","border-style":"none"},"id":"a5fa884e620f","title":"三"}],"root":true,"theme":"customise_7fd055efa78b","style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","font-weight":"bold","font-size":15,"border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"root","title":"从&nbsp;Class&nbsp;迁移到&nbsp;Hook<br>","icons":[{"color":"rgb(255, 255, 255)","name":"","index":"46","text":"&#xe693"}],"structure":"mind_right"}},"meta":{"exportTime":"2022-04-10 23:22:41","member":"60cca488e0b34d55bbf2954f","diagramInfo":{"creator":"60cca488e0b34d55bbf2954f","created":"2022-04-10 23:15:35","modified":"2022-04-10 23:22:30","title":"5.8.2Hooks FAQ之从 Class 迁移到 Hoo","category":"mind_free"},"id":"6252f4971e085332f338e05b","type":"ProcessOn Schema File","version":"1.0"}}