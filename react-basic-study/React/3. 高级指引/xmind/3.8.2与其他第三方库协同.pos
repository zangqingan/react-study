{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"note":"","margin":{"childMarginW":10,"childMarginH":5,"marginW":20,"marginH":10},"watermark":"","children":[{"parent":"root","lineStyle":{"lineColor":"#1976D2"},"children":[{"parent":"3b7f7da9d693","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[],"style":{"lineStype":{"lineType":"curve","lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","bold":false,"font-style":"normal","italic":false},"id":"3da828dbd224","title":"得益于&nbsp;ReactDOM.render()&nbsp;的灵活性&nbsp;React&nbsp;可以被嵌入到其他的应用中。<br>虽然&nbsp;React&nbsp;通常被用来在启动的时候加载一个单独的根&nbsp;React&nbsp;组件到&nbsp;DOM&nbsp;上，ReactDOM.render()&nbsp;同样可以在&nbsp;UI&nbsp;的独立部分上多次调用，这些部分可以小到一个按钮，也可以大到一个应用","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"3b7f7da9d693","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[{"parent":"4d0baeac4530","children":[],"id":"012f5e2a2b2b","title":"在旧的&nbsp;web&nbsp;应用中一个通用的模式就是使用一个字符串描述&nbsp;DOM&nbsp;块并且通过类似&nbsp;$el.html(htmlString)&nbsp;这样的方式插入到&nbsp;DOM&nbsp;中。<br>代码库中的这种例子是非常适合引入&nbsp;React&nbsp;的。直接把基于字符串的渲染重写成&nbsp;React&nbsp;组件即可"},{"parent":"4d0baeac4530","children":[{"parent":"0ec75ce12d83","note":"那么下面这段 jQuery 的实现…\n\n$(&#39;#container&#39;).html(&#39;&lt;button id=&quot;btn&quot;&gt;Say Hello&lt;/button&gt;&#39;);\n$(&#39;#btn&#39;).click(function() {\n  alert(&#39;Hello!&#39;);\n});\n…可以使用 React 组件重写为：\n\nfunction Button() {\n  return &lt;button id=&quot;btn&quot;&gt;Say Hello&lt;/button&gt;;\n}\n\nReactDOM.render(\n  &lt;Button /&gt;,\n  document.getElementById(&#39;container&#39;),\n  function() {\n    $(&#39;#btn&#39;).click(function() {\n      alert(&#39;Hello!&#39;);\n    });\n  }\n);\n从这起你可开始以把更多的逻辑移动到组件中，并且开始应用更多通用 React 实践。例如，在组件中最好不要依赖 ID 因为同一个组件可能会被渲染多次。相反的，我们会使用 React 事件系统 并且直接注册 click 处理函数到 React &lt;button&gt; 元素：\n\nfunction Button(props) {\n  return &lt;button onClick={props.onClick}&gt;Say Hello&lt;/button&gt;;\n}\n\nfunction HelloButton() {\n  function handleClick() {\n    alert(&#39;Hello!&#39;);\n  }\n  return &lt;Button onClick={handleClick} /&gt;;\n}\n\nReactDOM.render(\n  &lt;HelloButton /&gt;,\n  document.getElementById(&#39;container&#39;)\n);","children":[],"id":"189c697628e9","title":"代码"}],"id":"0ec75ce12d83","title":"例子"},{"parent":"4d0baeac4530","children":[],"id":"d2bbf42253e3","title":"只要你喜欢你可以有不限数量的这种独立组件，并且使用&nbsp;ReactDOM.render()&nbsp;把他们渲染到不同的容器中。<br>逐渐的，随着你把越来越多的应用转换到&nbsp;React，你就可以把它们结合成更大的组件，并且把&nbsp;ReactDOM.render()&nbsp;的调用移动到更上层的结构"}],"style":{"lineStype":{"lineType":"curve","lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","bold":false,"font-style":"normal","italic":false},"id":"4d0baeac4530","title":"利用&nbsp;React&nbsp;替换基于字符串的渲染","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"3b7f7da9d693","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[{"parent":"6c79dfddc125","children":[],"id":"5d2af2e51254","title":"Backbone&nbsp;视图通常使用&nbsp;HTML&nbsp;字符串，或者产生字符串的模板函数，来创建&nbsp;DOM&nbsp;元素的内容。<br>这个过程，同样的，可以通过渲染一个&nbsp;React&nbsp;组件来替换掉"},{"parent":"6c79dfddc125","children":[{"parent":"b3725524d54c","note":"如下，我们会创建一个名为 ParagraphView 的 Backbone 视图。他会重载 Backbone 的 render() 函数来渲染一个 React &lt;Paragraph&gt; 组件到 Backbone (this.el) 提供的 DOM 元素中。这里，同样的，我们将会使用 ReactDOM.render()：\n\nfunction Paragraph(props) {\n  return &lt;p&gt;{props.text}&lt;/p&gt;;\n}\n\nconst ParagraphView = Backbone.View.extend({\n  render() {\n    const text = this.model.get(&#39;text&#39;);\n    ReactDOM.render(&lt;Paragraph text={text} /&gt;, this.el);\n    return this;\n  },\n  remove() {\n    ReactDOM.unmountComponentAtNode(this.el);\n    Backbone.View.prototype.remove.call(this);\n  }\n});","children":[],"id":"667193c2a78f","title":"代码"}],"id":"b3725524d54c","title":"例"}],"style":{"lineStype":{"lineType":"curve","lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","bold":false,"font-style":"normal","italic":false},"id":"6c79dfddc125","title":"把&nbsp;React&nbsp;嵌入到&nbsp;Backbone&nbsp;视图","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"2","text":"&#xe62a"}]}],"boundaries":[],"style":{"background-color":"#1976D2","border-radius":"5px","font-weight":"bold","font-size":13},"id":"3b7f7da9d693","title":"和其他视图库集成"},{"parent":"root","lineStyle":{"randomLineColor":"rgb(255,204,204)","lineColor":"#7B1FA2"},"children":[{"parent":"812b3a9306dd","note":"","children":[],"style":{"font-weight":"normal"},"id":"ac25a09c6779","title":"虽然通常是推荐使用单向数据流动的，例如&nbsp;React&nbsp;state，Flux，或者&nbsp;Redux，React&nbsp;组件也可以使用一个其他框架和库的&nbsp;Model&nbsp;层","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"812b3a9306dd","note":"","children":[{"parent":"4d70d73dad33","children":[],"id":"e25aa2531a92","title":"在&nbsp;React&nbsp;组件中使用&nbsp;Backbone&nbsp;的&nbsp;model&nbsp;和&nbsp;collection&nbsp;最简单的方法就是监听多种变化事件并且手动强制触发一个更新"},{"parent":"4d70d73dad33","children":[],"id":"aaf04c28c5e2","title":"负责渲染&nbsp;model&nbsp;的组件会监听&nbsp;'change'&nbsp;事件，而负责渲染&nbsp;collection&nbsp;的组件需要监听&nbsp;'add'&nbsp;和&nbsp;'remove'&nbsp;事件。<br>在这两种情况中，调用&nbsp;this.forceUpdate()&nbsp;来使用新的数据重新渲染组件"},{"parent":"4d70d73dad33","note":"在下面的例子中，List 组件渲染一个 Backbone collection，使用 Item 组件来渲染独立的项。\n\nclass Item extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n  }\n\n  handleChange() {\n    this.forceUpdate();\n  }\n\n  componentDidMount() {\n    this.props.model.on(&#39;change&#39;, this.handleChange);\n  }\n\n  componentWillUnmount() {\n    this.props.model.off(&#39;change&#39;, this.handleChange);\n  }\n\n  render() {\n    return &lt;li&gt;{this.props.model.get(&#39;text&#39;)}&lt;/li&gt;;\n  }\n}\n\nclass List extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n  }\n\n  handleChange() {\n    this.forceUpdate();\n  }\n\n  componentDidMount() {\n    this.props.collection.on(&#39;add&#39;, &#39;remove&#39;, this.handleChange);\n  }\n\n  componentWillUnmount() {\n    this.props.collection.off(&#39;add&#39;, &#39;remove&#39;, this.handleChange);\n  }\n\n  render() {\n    return (\n      &lt;ul&gt;\n        {this.props.collection.map(model =&gt; (\n          &lt;Item key={model.cid} model={model} /&gt;\n        ))}\n      &lt;/ul&gt;\n    );\n  }\n}","children":[],"id":"c1eab91aad3c","title":"例子"}],"style":{"font-weight":"normal"},"id":"4d70d73dad33","title":"在&nbsp;React&nbsp;组件中使用&nbsp;Backbone&nbsp;的&nbsp;Model","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"812b3a9306dd","children":[{"parent":"3ce2e9e4fcdf","children":[],"id":"8ce7254cb3b1","title":"前面的方式需要你的&nbsp;React&nbsp;组件知道&nbsp;Backbone&nbsp;的&nbsp;model&nbsp;和&nbsp;collection。<br>如果你计划迁移到另一个数据管理方案，你可能希望将关于Backbone的知识集中在尽可能少的代码部分中。<br>其中一个解决方案就是每当&nbsp;model&nbsp;中的属性变化时都把它提取成简单数据，并且把这个逻辑放在一个独立的地方。<br>下面是一个高阶组件，它提取了&nbsp;Backbone&nbsp;model&nbsp;的所有数据存放到&nbsp;state&nbsp;中，并将数据传递到被包裹的组件中。<br>通过这种方法，只有高阶组件需要知道&nbsp;Backbone&nbsp;model&nbsp;的内部构造，而且应用中大多数的组件可以保持和&nbsp;Backbone&nbsp;无关"},{"parent":"3ce2e9e4fcdf","note":"在下面的例子中，我们会拷贝一份 model 的属性来形成初始的 state。我们订阅 change 事件（并且在取消挂载时停止订阅），而当变化发生时，我们使用 model 的当前属性更新这个 state。最终，我们确保了只要 model 属性本身变化的时候，我们不要忘了停止旧 model 的订阅并开始订阅新的 model。\n\n请注意，这个例子并不是为了彻底完整展示如何与 Backbone 集成，而是它应该让你了解如何以通用的方式处理此问题：\n\nfunction connectToBackboneModel(WrappedComponent) {\n  return class BackboneComponent extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = Object.assign({}, props.model.attributes);\n      this.handleChange = this.handleChange.bind(this);\n    }\n\n    componentDidMount() {\n      this.props.model.on(&#39;change&#39;, this.handleChange);\n    }\n\n    componentWillReceiveProps(nextProps) {\n      this.setState(Object.assign({}, nextProps.model.attributes));\n      if (nextProps.model !== this.props.model) {\n        this.props.model.off(&#39;change&#39;, this.handleChange);\n        nextProps.model.on(&#39;change&#39;, this.handleChange);\n      }\n    }\n\n    componentWillUnmount() {\n      this.props.model.off(&#39;change&#39;, this.handleChange);\n    }\n\n    handleChange(model) {\n      this.setState(model.changedAttributes());\n    }\n\n    render() {\n      const propsExceptModel = Object.assign({}, this.props);\n      delete propsExceptModel.model;\n      return &lt;WrappedComponent {...propsExceptModel} {...this.state} /&gt;;\n    }\n  }\n}\n要演示如何使用它，我们会链接一个 NameInput React 组件到一个 Backbone model，并且每当输入框变化时更新它的 firstName 属性：\n\nfunction NameInput(props) {\n  return (\n    &lt;p&gt;\n      &lt;input value={props.firstName} onChange={props.handleChange} /&gt;\n      &lt;br /&gt;\n      My name is {props.firstName}.\n    &lt;/p&gt;\n  );\n}\n\nconst BackboneNameInput = connectToBackboneModel(NameInput);\n\nfunction Example(props) {\n  function handleChange(e) {\n    props.model.set(&#39;firstName&#39;, e.target.value);\n  }\n\n  return (\n    &lt;BackboneNameInput\n      model={props.model}\n      handleChange={handleChange}\n    /&gt;\n\n  );\n}\n\nconst model = new Backbone.Model({ firstName: &#39;Frodo&#39; });\nReactDOM.render(\n  &lt;Example model={model} /&gt;,\n  document.getElementById(&#39;root&#39;)\n);","children":[],"id":"1f10a5075b70","title":"例子"},{"parent":"3ce2e9e4fcdf","children":[],"id":"e3146eed3971","title":"这个技术并不仅限于&nbsp;Backbone。你可以通过在生命周期方法中订阅其更改并，并选择性地，拷贝数据到本地&nbsp;React&nbsp;state，来将&nbsp;React&nbsp;用于任何&nbsp;model&nbsp;库"}],"style":{"font-weight":"normal"},"id":"3ce2e9e4fcdf","title":"从&nbsp;Backbone&nbsp;Model&nbsp;提取数据","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"2","text":"&#xe62a"}]}],"style":{"background-color":"#7B1FA2","border-radius":"5px","color":"rgb(255, 255, 255)","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"812b3a9306dd","title":"和&nbsp;Model&nbsp;层集成"}],"root":true,"theme":"customise_7fd055efa78b","style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","font-weight":"bold","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"root","title":"与其他第三方库协同","icons":[{"color":"rgb(255, 255, 255)","name":"","index":"48"}],"structure":"mind_free"}},"meta":{"exportTime":"2022-04-06 18:09:33","member":"60cca488e0b34d55bbf2954f","diagramInfo":{"creator":"60cca488e0b34d55bbf2954f","created":"2022-04-06 18:01:19","modified":"2022-04-06 18:09:10","title":"3.8.2与其他第三方库协同","category":"mind_free"},"id":"624d64eff346fb57dbecff31","type":"ProcessOn Schema File","version":"1.0"}}