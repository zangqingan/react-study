{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"note":"","watermark":"","children":[{"parent":"root","lineStyle":{"lineColor":"#BBDEFB"},"children":[{"parent":"812b3a9306dd","children":[],"id":"93f2e74f29a2","title":"Ref&nbsp;转发是一项将&nbsp;ref&nbsp;自动地通过组件传递到其一子组件的技巧。<br>对于大多数应用中的组件来说，这通常不是必需的。但其对某些组件，尤其是可重用的组件库是很有用的"}],"style":{"background-color":"#BBDEFB","border-radius":"5px","color":"#212121","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"812b3a9306dd","title":"介绍<br>"},{"parent":"root","lineStyle":{"lineColor":"#E1BEE7","lineWidth":"2"},"children":[{"parent":"896498dd7718","note":"","children":[{"parent":"3c25c1c2ba10","note":"function FancyButton(props) {\n  return (\n    &lt;button className=&quot;FancyButton&quot;&gt;\n      {props.children}\n    &lt;/button&gt;\n  );\n}","children":[],"id":"b04aa0b906b6","title":"代码"},{"parent":"3c25c1c2ba10","children":[],"id":"43150597b87b","title":"React&nbsp;组件隐藏其实现细节，包括其渲染结果。其他使用&nbsp;FancyButton&nbsp;的组件通常不需要获取<br>内部的&nbsp;DOM&nbsp;元素&nbsp;button&nbsp;的&nbsp;ref。这很好，因为这防止组件过度依赖其他组件的&nbsp;DOM&nbsp;结构"}],"id":"3c25c1c2ba10","title":"考虑这个渲染原生&nbsp;DOM&nbsp;元素&nbsp;button&nbsp;的&nbsp;FancyButton&nbsp;组件","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"896498dd7718","children":[],"id":"4be7280572a9","title":"虽然这种封装对类似&nbsp;FeedStory&nbsp;或&nbsp;Comment&nbsp;这样的应用级组件是理想的，但其对FancyButton或MyTextInput这样的高可复用“叶”组件来说可能是不方便的。这些组件倾向于在整个应用中以一种类似常规&nbsp;DOM&nbsp;button&nbsp;和&nbsp;input&nbsp;的方式被使用，并且访问其&nbsp;DOM&nbsp;节点对管理焦点，选中或动画来说是不可避免<br>","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"896498dd7718","children":[],"style":{"color":"#E57373","font-weight":"bold"},"id":"d7a2018a01ad","title":"Ref&nbsp;转发是一个可选特性，其允许某些组件接收&nbsp;ref，并将其向下传递（换句话说，“转发”它）给子组件。","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"2","text":"&#xe62a"}]},{"parent":"896498dd7718","children":[{"parent":"0e4e1cbc9688","note":"const FancyButton = React.forwardRef((props, ref) =&gt; (\n  &lt;button ref={ref} className=&quot;FancyButton&quot;&gt;\n    {props.children}\n  &lt;/button&gt;\n));\n\n// 你可以直接获取 DOM button 的 ref：\nconst ref = React.createRef();\n&lt;FancyButton ref={ref}&gt;Click me!&lt;/FancyButton&gt;;\n\n\n以下是对上述示例发生情况的逐步解释：\n\n1.我们通过调用 React.createRef 创建了一个 React ref 并将其赋值给 ref 变量。\n2.我们通过指定 ref 为 JSX 属性，将其向下传递给 &lt;FancyButton ref={ref}&gt;。\n3.React 传递 ref 给 forwardRef 内函数 (props, ref) =&gt; ...，作为其第二个参数。\n4.我们向下转发该 ref 参数到 &lt;button ref={ref}&gt;，将其指定为 JSX 属性。\n5.当 ref 挂载完成，ref.current 将指向 &lt;button&gt; DOM 节点。","children":[],"id":"ed8abb76b6d5","title":"代码"},{"parent":"0e4e1cbc9688","children":[],"id":"bfdbeebd7ddf","title":"这样，使用&nbsp;FancyButton&nbsp;的组件可以获取底层&nbsp;DOM&nbsp;节点&nbsp;button&nbsp;的&nbsp;ref&nbsp;，<br>并在必要时访问，就像其直接使用&nbsp;DOM&nbsp;button&nbsp;一样"}],"id":"0e4e1cbc9688","title":"在下面的示例中，FancyButton&nbsp;使用&nbsp;React.forwardRef&nbsp;来获取传递给它的&nbsp;ref，<br>然后转发到它渲染的&nbsp;DOM&nbsp;button","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"3","text":"&#xe635"}]},{"parent":"896498dd7718","children":[{"parent":"56f3a9520c1a","children":[],"id":"4d4f62811659","title":"第二个参数&nbsp;ref&nbsp;只在使用&nbsp;React.forwardRef&nbsp;定义组件时存在。常规函数和&nbsp;class&nbsp;组件不接收&nbsp;ref&nbsp;参数，且&nbsp;props&nbsp;中也不存在&nbsp;ref。<br>Ref&nbsp;转发不仅限于&nbsp;DOM&nbsp;组件，你也可以转发&nbsp;refs&nbsp;到&nbsp;class&nbsp;组件实例中"}],"id":"56f3a9520c1a","title":"注意"}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"font-style":"normal","border-radius":"5px","background-color":"#E1BEE7","lineStype":{"lineColor":"#E1BEE7","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#E1BEE7","lineWidth":"2"},"font-family":"微软雅黑","border-width":0,"border-style":"solid"},"id":"896498dd7718","title":"转发&nbsp;refs&nbsp;到&nbsp;DOM&nbsp;组件<br>"},{"parent":"root","lineStyle":{"lineColor":"#FFCDD2","lineWidth":"2"},"children":[{"parent":"5bf8fe5c3c71","children":[],"id":"9977131486f1","title":"当你开始在组件库中使用&nbsp;forwardRef&nbsp;时，你应当将其视为一个破坏性更改，并发布库的一个新的主版本。&nbsp;这是因为你的库可能会有明显不同的行为（例如&nbsp;refs&nbsp;被分配给了谁，以及导出了什么类型），并且这样可能会导致依赖旧行为的应用和其他库崩溃。<br>出于同样的原因，当&nbsp;React.forwardRef&nbsp;存在时有条件地使用它也是不推荐的：它改变了你的库的行为，并在升级&nbsp;React&nbsp;自身时破坏用户的应用"}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","font-style":"normal","border-radius":"5px","background-color":"#FFCDD2","lineStype":{"lineColor":"#FFCDD2","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#FFCDD2","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"font-family":"微软雅黑","border-width":"0px","border-style":"none"},"id":"5bf8fe5c3c71","title":"组件库维护者的注意事项<br>"},{"parent":"root","lineStyle":{"lineColor":"#C8E6C9","lineWidth":"2"},"children":[{"parent":"a01eafed5bb9","note":"","children":[{"parent":"15028f67c0e5","note":"function logProps(WrappedComponent) {\n  class LogProps extends React.Component {\n    componentDidUpdate(prevProps) {\n      console.log(&#39;old props:&#39;, prevProps);\n      console.log(&#39;new props:&#39;, this.props);\n    }\n\n    render() {\n      return &lt;WrappedComponent {...this.props} /&gt;;\n    }\n  }\n\n  return LogProps;\n}","children":[],"id":"1e4ebdb633e0","title":"代码"}],"id":"15028f67c0e5","title":"这个技巧对高阶组件（也被称为&nbsp;HOC）特别有用。让我们从一个输出组件&nbsp;props&nbsp;到控制台的&nbsp;HOC&nbsp;示例开始","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"a01eafed5bb9","children":[{"parent":"412c765359ca","note":"class FancyButton extends React.Component {\n  focus() {\n    // ...\n  }\n\n  // ...\n}\n\n// 我们导出 LogProps，而不是 FancyButton。\n// 虽然它也会渲染一个 FancyButton。\nexport default logProps(FancyButton);","children":[],"id":"f3fa625daaef","title":"代码"}],"id":"412c765359ca","title":"“logProps”&nbsp;HOC&nbsp;透传（pass&nbsp;through）所有&nbsp;props&nbsp;到其包裹的组件，所以渲染结果将是相同的。<br>例如：我们可以使用该&nbsp;HOC&nbsp;记录所有传递到&nbsp;“fancy&nbsp;button”&nbsp;组件的&nbsp;props<br>","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"a01eafed5bb9","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[{"parent":"793c480c9601","note":"import FancyButton from &#39;./FancyButton&#39;;\n\nconst ref = React.createRef();\n\n// 我们导入的 FancyButton 组件是高阶组件（HOC）LogProps。\n// 尽管渲染结果将是一样的，\n// 但我们的 ref 将指向 LogProps 而不是内部的 FancyButton 组件！\n// 这意味着我们不能调用例如 ref.current.focus() 这样的方法\n&lt;FancyButton\n  label=&quot;Click Me&quot;\n  handleClick={handleClick}\n  ref={ref}\n/&gt;;","children":[],"id":"c6c8d49e2408","title":"代码"}],"style":{"lineStype":{"lineType":"roundBroken","lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","bold":false,"font-style":"normal","italic":false},"id":"793c480c9601","title":"上面的示例有一点需要注意：refs&nbsp;将不会透传下去。这是因为&nbsp;ref&nbsp;不是&nbsp;prop&nbsp;属性。就像&nbsp;key&nbsp;一样，其被&nbsp;React&nbsp;进行了特殊处理。如果你对&nbsp;HOC&nbsp;添加&nbsp;ref，该&nbsp;ref&nbsp;将引用最外层的容器组件，而不是被包裹的组件。<br>这意味着用于我们&nbsp;FancyButton&nbsp;组件的&nbsp;refs&nbsp;实际上将被挂载到&nbsp;LogProps&nbsp;组件","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"2","text":"&#xe62a"}]},{"parent":"a01eafed5bb9","children":[{"parent":"d39b88848e99","note":"function logProps(Component) {\n  class LogProps extends React.Component {\n    componentDidUpdate(prevProps) {\n      console.log(&#39;old props:&#39;, prevProps);\n      console.log(&#39;new props:&#39;, this.props);\n    }\n\n    render() {\n      const {forwardedRef, ...rest} = this.props;\n\n      // 将自定义的 prop 属性 “forwardedRef” 定义为 ref\n      return &lt;Component ref={forwardedRef} {...rest} /&gt;;\n    }\n  }\n\n  // 注意 React.forwardRef 回调的第二个参数 “ref”。\n  // 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”\n  // 然后它就可以被挂载到被 LogProps 包裹的子组件上。\n  return React.forwardRef((props, ref) =&gt; {\n    return &lt;LogProps {...props} forwardedRef={ref} /&gt;;\n  });\n}","children":[],"id":"ec4529061311","title":"例如"}],"id":"d39b88848e99","title":"幸运的是，我们可以使用&nbsp;React.forwardRef&nbsp;API&nbsp;明确地将&nbsp;refs&nbsp;转发到内部的&nbsp;FancyButton&nbsp;组件。<br>React.forwardRef&nbsp;接受一个渲染函数，其接收&nbsp;props&nbsp;和&nbsp;ref&nbsp;参数并返回一个&nbsp;React&nbsp;节点","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"3","text":"&#xe635"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","font-style":"normal","border-radius":"5px","background-color":"#C8E6C9","lineStype":{"lineColor":"#F57F17","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#C8E6C9","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"font-family":"微软雅黑","border-width":"0px","border-style":"none"},"id":"a01eafed5bb9","title":"在高阶组件中转发&nbsp;refs<br>"},{"parent":"root","lineStyle":{"lineColor":"#FFE0B2","lineWidth":"2"},"children":[{"parent":"cecb23f7996e","note":"","children":[],"id":"10eb40fe09d6","title":"React.forwardRef&nbsp;接受一个渲染函数。React&nbsp;DevTools&nbsp;使用该函数来决定为&nbsp;ref&nbsp;转发组件显示的内容","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"cecb23f7996e","children":[{"parent":"9e830d23e729","note":"例如，以下组件将在 DevTools 中显示为 “ForwardRef”：\n\nconst WrappedComponent = React.forwardRef((props, ref) =&gt; {\n  return &lt;LogProps {...props} forwardedRef={ref} /&gt;;\n});\n如果你命名了渲染函数，DevTools 也将包含其名称（例如 “ForwardRef(myFunction)”）：\n\nconst WrappedComponent = React.forwardRef(\n  function myFunction(props, ref) {\n    return &lt;LogProps {...props} forwardedRef={ref} /&gt;;\n  }\n);\n你甚至可以设置函数的 displayName 属性来包含被包裹组件的名称：\n\nfunction logProps(Component) {\n  class LogProps extends React.Component {\n    // ...\n  }\n\n  function forwardRef(props, ref) {\n    return &lt;LogProps {...props} forwardedRef={ref} /&gt;;\n  }\n\n  // 在 DevTools 中为该组件提供一个更有用的显示名。\n  // 例如 “ForwardRef(logProps(MyComponent))”\n  const name = Component.displayName || Component.name;\n  forwardRef.displayName = `logProps(${name})`;\n\n  return React.forwardRef(forwardRef);\n}","children":[],"id":"2698d5df1aa1","title":"代码"}],"id":"9e830d23e729","title":"例","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"font-style":"normal","border-radius":"5px","background-color":"#FFE0B2","lineStype":{"lineColor":"#FFE0B2","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#FFE0B2","lineWidth":"2"},"font-family":"微软雅黑","border-width":0,"border-style":"solid"},"id":"cecb23f7996e","title":"在&nbsp;DevTools&nbsp;中显示自定义名称<br>"}],"root":true,"theme":"customise_7fd055efa78b","style":{"background-color":"#2196F3","border-radius":"6px","color":"rgb(255, 255, 255)","font-weight":"bold","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"root","title":"Refs&nbsp;转发","icons":[{"color":"rgb(255, 255, 255)","name":"","index":"46"}],"structure":"mind_free"}},"meta":{"exportTime":"2022-04-06 16:56:33","member":"60cca488e0b34d55bbf2954f","diagramInfo":{"creator":"60cca488e0b34d55bbf2954f","created":"2022-04-06 16:39:15","modified":"2022-04-06 16:56:25","title":"3.5Refs 转发","category":"mind_free"},"id":"624d51b3079129641e41b567","type":"ProcessOn Schema File","version":"1.0"}}