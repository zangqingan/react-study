{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"note":"","margin":{"childMarginW":10,"childMarginH":5,"marginW":20,"marginH":10},"watermark":"","children":[{"parent":"root","lineStyle":{"randomLineColor":"rgb(255,204,204)","lineColor":"#7B1FA2"},"children":[{"parent":"812b3a9306dd","note":"","children":[],"style":{"font-weight":"normal"},"id":"ac25a09c6779","title":"如果你的应用渲染了长列表（上百甚至上千的数据），我们推荐使用“虚拟滚动”技术","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"812b3a9306dd","note":"","children":[],"style":{"font-weight":"normal"},"id":"4d70d73dad33","title":"这项技术会在有限的时间内仅渲染有限的内容，并奇迹般地降低重新渲染组件消耗的时间，以及创建&nbsp;DOM&nbsp;节点的数量","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"812b3a9306dd","children":[],"style":{"font-weight":"normal"},"id":"3ce2e9e4fcdf","title":"react-window&nbsp;和&nbsp;react-virtualized&nbsp;是热门的虚拟滚动库。&nbsp;它们提供了多种可复用的组件，用于展示列表、网格和表格数据。&nbsp;<br>如果你想要一些针对你的应用做定制优化，你也可以创建你自己的虚拟滚动组件，就像&nbsp;Twitter&nbsp;所做的","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"2","text":"&#xe62a"}]}],"style":{"background-color":"#7B1FA2","border-radius":"5px","color":"rgb(255, 255, 255)","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"812b3a9306dd","title":"虚拟化长列表"},{"parent":"root","lineStyle":{"lineColor":"#1976D2"},"children":[{"parent":"3b7f7da9d693","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[],"style":{"lineStype":{"lineType":"curve","lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","bold":false,"font-style":"normal","italic":false},"id":"3da828dbd224","title":"React&nbsp;构建并维护了一套内部的&nbsp;UI&nbsp;渲染描述。它包含了来自你的组件返回的&nbsp;React&nbsp;元素。该描述使得&nbsp;React&nbsp;避免创建&nbsp;DOM&nbsp;节点以及没有必要的节点访问，因为&nbsp;DOM&nbsp;操作相对于&nbsp;JavaScript&nbsp;对象操作更慢。虽然有时候它被称为“虚拟&nbsp;DOM”，但是它在&nbsp;React&nbsp;Native&nbsp;中拥有相同的工作原理","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"3b7f7da9d693","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[],"style":{"lineStype":{"lineType":"curve","lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","bold":false,"font-style":"normal","italic":false},"id":"4d0baeac4530","title":"当一个组件的&nbsp;props&nbsp;或&nbsp;state&nbsp;变更，React&nbsp;会将最新返回的元素与之前渲染的元素进行对比，以此决定是否有必要更新真实的&nbsp;DOM。<br>当它们不相同时，React&nbsp;会更新该&nbsp;DOM","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"3b7f7da9d693","note":"shouldComponentUpdate(nextProps, nextState) {\n  return true;\n}","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[],"style":{"lineStype":{"lineType":"curve","lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","bold":false,"font-style":"normal","italic":false},"id":"6c79dfddc125","title":"即使&nbsp;React&nbsp;只更新改变了的&nbsp;DOM&nbsp;节点，重新渲染仍然花费了一些时间。在大部分情况下它并不是问题，不过如果它已经慢到让人注意了，你可以通过覆盖生命周期方法&nbsp;shouldComponentUpdate&nbsp;来进行提速。该方法会在重新渲染前被触发。其默认实现总是返回&nbsp;true，让&nbsp;React&nbsp;执行更新","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"2","text":"&#xe62a"}]},{"parent":"3b7f7da9d693","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[],"style":{"lineStype":{"lineType":"curve","lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","bold":false,"font-style":"normal","italic":false},"id":"7d31ff9ecdae","title":"如果你知道在什么情况下你的组件不需要更新，你可以在&nbsp;shouldComponentUpdate&nbsp;中返回&nbsp;false&nbsp;来跳过整个渲染过程。其包括该组件的&nbsp;render&nbsp;调用以及之后的操作。<br>在大部分情况下，你可以继承&nbsp;React.PureComponent&nbsp;以代替手写&nbsp;shouldComponentUpdate()。它用当前与之前&nbsp;props&nbsp;和&nbsp;state&nbsp;的浅比较覆写了&nbsp;shouldComponentUpdate()&nbsp;的实现<br>","icons":[{"color":"rgb(48, 191, 191)","name":"priority","index":"3","text":"&#xe635"}]}],"boundaries":[],"style":{"background-color":"#1976D2","border-radius":"5px","font-weight":"bold","font-size":13},"id":"3b7f7da9d693","title":"避免调停"},{"parent":"root","lineStyle":{"randomLineColor":"rgb(153,204,255)","lineColor":"#388E3C"},"children":[{"parent":"0291282e6d37","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[{"parent":"8759611ecbbe","image":{"w":206,"h":138,"url":"http://cdn.processon.com/624f89b50e3e741168303f41?e=1649383365&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:0yuNpPi0_WpmXeaokb_fz7ghk-c="},"children":[],"id":"a930ad852959","title":""}],"style":{"lineStype":{"lineType":"curve","lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","bold":false,"font-style":"normal","italic":false},"id":"8759611ecbbe","title":"这是一个组件的子树。<br>每个节点中，SCU&nbsp;代表&nbsp;shouldComponentUpdate&nbsp;返回的值，<br>而&nbsp;vDOMEq&nbsp;代表返回的&nbsp;React&nbsp;元素是否相同。<br>最后，圆圈的颜色代表了该组件是否需要被调停","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"0291282e6d37","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[],"style":{"lineStype":{"lineType":"curve","lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","bold":false,"font-style":"normal","italic":false},"id":"83be2310dcad","title":"节点&nbsp;C2&nbsp;的&nbsp;shouldComponentUpdate&nbsp;返回了&nbsp;false，React&nbsp;因而不会去渲染&nbsp;C2，也因此&nbsp;C4&nbsp;和&nbsp;C5&nbsp;的&nbsp;shouldComponentUpdate&nbsp;不会被调用到。<br><br>对于&nbsp;C1&nbsp;和&nbsp;C3，shouldComponentUpdate&nbsp;返回了&nbsp;true，所以&nbsp;React&nbsp;需要继续向下查询子节点。这里&nbsp;C6&nbsp;的&nbsp;shouldComponentUpdate&nbsp;返回了&nbsp;true，同时由于渲染的元素与之前的不同使得&nbsp;React&nbsp;更新了该&nbsp;DOM。<br><br>最后一个有趣的例子是&nbsp;C8。React&nbsp;需要渲染这个组件，但是由于其返回的&nbsp;React&nbsp;元素和之前渲染的相同，所以不需要更新&nbsp;DOM。<br><br>显而易见，你看到&nbsp;React&nbsp;只改变了&nbsp;C6&nbsp;的&nbsp;DOM。对于&nbsp;C8，通过对比了渲染的&nbsp;React&nbsp;元素跳过了渲染。而对于&nbsp;C2&nbsp;的子节点和&nbsp;C7，由于&nbsp;shouldComponentUpdate&nbsp;使得&nbsp;render&nbsp;并没有被调用。因此它们也不需要对比元素了","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"1","text":"&#xe625"}]}],"style":{"background-color":"#388E3C","border-radius":"5px","color":"rgb(255, 255, 255)","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"0291282e6d37","title":"shouldComponentUpdate&nbsp;的作用<br>"},{"parent":"root","lineStyle":{"randomLineColor":"rgb(153,204,255)","lineColor":"#F57F17"},"children":[{"parent":"b653f7534587","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[],"style":{"lineStype":{"lineType":"curve","lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","bold":false,"font-style":"normal","italic":false},"id":"09c359863911","title":"ES6&nbsp;数组支持扩展运算符，这让代码写起来更方便了。如果你在使用&nbsp;Create&nbsp;React&nbsp;App，该语法已经默认支持","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"b653f7534587","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[{"parent":"a055a844090f","children":[],"style":{"background-color":"#F5F5F5"},"id":"4130f249361b","title":"function&nbsp;updateColorMap(colormap)&nbsp;{\n&nbsp;&nbsp;colormap.right&nbsp;=&nbsp;'blue';\n}"}],"boundaries":[{"boundary":true,"parent":"a055a844090f","boundRank":1,"children":[],"pos":{"miny":10239,"minx":10966,"maxY":10315,"maxX":11236},"range":"0,0","style":{"lineType":"1","dasharray":"6,3","lineColor":"#63abf7","opacity":"0.1","fill":"#63abf7","lineWidth":"1"},"id":"c279220d61f0","title":"外框"}],"style":{"lineStype":{"lineType":"curve","lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","bold":false,"font-style":"normal","italic":false},"id":"a055a844090f","title":"你可以用类似的方式改写代码来避免可变对象的产生。<br>例如，我们有一个叫做&nbsp;colormap&nbsp;的对象。我们希望写一个方法来将&nbsp;colormap.right&nbsp;设置为&nbsp;'blue'。我们可以这么写<br>","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"b653f7534587","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[{"parent":"0dfdea6aa31e","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[],"style":{"background-color":"#F5F5F5","lineStype":{"lineType":"roundBroken","lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","bold":false,"font-style":"normal","italic":false},"id":"61f92760a9fa","title":"function&nbsp;updateColorMap(colormap)&nbsp;{\n&nbsp;&nbsp;return&nbsp;Object.assign({},&nbsp;colormap,&nbsp;{right:&nbsp;'blue'});\n}"}],"boundaries":[{"boundary":true,"parent":"0dfdea6aa31e","boundRank":1,"children":[],"range":"0,0","style":{"lineType":"1","dasharray":"6,3","lineColor":"#63abf7","fill":"#63abf7","opacity":"0.1","lineWidth":"1"},"id":"073acae6a901","title":"外框"}],"style":{"lineStype":{"lineType":"curve","lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","bold":false,"font-style":"normal","italic":false},"id":"0dfdea6aa31e","title":"为了不改变原本的对象，我们可以使用&nbsp;Object.assign&nbsp;方法","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"2","text":"&#xe62a"}]},{"parent":"b653f7534587","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[{"parent":"b85aeefbb127","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[],"style":{"background-color":"#F5F5F5","lineStype":{"lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","bold":false,"font-style":"normal","italic":false},"id":"f05970d1d7fb","title":"function&nbsp;updateColorMap(colormap)&nbsp;{\n&nbsp;&nbsp;return&nbsp;{...colormap,&nbsp;right:&nbsp;'blue'};\n}"}],"boundaries":[{"boundary":true,"parent":"b85aeefbb127","boundRank":1,"children":[],"range":"0,0","style":{"lineType":"1","dasharray":"6,3","lineColor":"#63abf7","fill":"#63abf7","opacity":"0.1","lineWidth":"1"},"id":"ff2137d9e501","title":"外框"}],"style":{"lineStype":{"lineType":"curve","lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","bold":false,"font-style":"normal","italic":false},"id":"b85aeefbb127","title":"现在&nbsp;updateColorMap&nbsp;返回了一个新的对象，而不是修改老对象。Object.assign&nbsp;是&nbsp;ES6&nbsp;的方法，需要&nbsp;polyfill<br>这里有一个&nbsp;JavaScript&nbsp;的提案，旨在添加对象扩展属性以使得更新不可变对象变得更方便<br>","icons":[{"color":"rgb(48, 191, 191)","name":"priority","index":"3","text":"&#xe635"}]},{"parent":"b653f7534587","children":[],"id":"b9ca299de579","title":"如果你在使用&nbsp;Create&nbsp;React&nbsp;App，Object.assign&nbsp;以及对象扩展运算符已经默认支持了。<br>当处理深层嵌套对象时，以&nbsp;immutable&nbsp;（不可变）的方式更新它们令人费解。如遇到此类问题，请参阅&nbsp;Immer&nbsp;或&nbsp;immutability-helper。这些库会帮助你编写高可读性的代码，且不会失去&nbsp;immutability&nbsp;（不可变性）带来的好处"}],"style":{"background-color":"#F57F17","border-radius":"5px","color":"rgb(255, 255, 255)","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"b653f7534587","title":"不可变数据的力量"}],"root":true,"theme":"customise_7fd055efa78b","style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","font-weight":"bold","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"root","title":"其他优化","icons":[{"color":"rgb(255, 255, 255)","name":"","index":"46","text":"&#xe693"}],"structure":"mind_free"}},"meta":{"exportTime":"2022-04-08 09:08:45","member":"60cca488e0b34d55bbf2954f","diagramInfo":{"creator":"60cca488e0b34d55bbf2954f","created":"2022-04-08 08:16:34","modified":"2022-04-08 09:08:22","title":"2.10.4其他优化","category":"mind_free"},"id":"624f7ee21efad4078916dc9a","type":"ProcessOn Schema File","version":"1.0"}}