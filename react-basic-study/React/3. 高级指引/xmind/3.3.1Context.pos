{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"note":"","watermark":"","children":[{"parent":"root","lineStyle":{"lineColor":"#BBDEFB"},"children":[{"parent":"812b3a9306dd","note":"","children":[],"id":"ac25a09c6779","title":"Context&nbsp;提供了一个无需为每层组件手动添加&nbsp;props，就能在组件树间进行数据传递的方法","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"812b3a9306dd","children":[],"id":"4d70d73dad33","title":"在一个典型的&nbsp;React&nbsp;应用中，数据是通过&nbsp;props&nbsp;属性自上而下（由父及子）进行传递的，但这种做法对于某些类型的属性而言是极其繁琐的（例如：地区偏好，UI&nbsp;主题），这些属性是应用程序中许多组件都需要的。Context&nbsp;提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递&nbsp;props<br>","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]}],"style":{"background-color":"#BBDEFB","border-radius":"5px","color":"#212121","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"812b3a9306dd","title":"介绍<br>"},{"parent":"root","lineStyle":{"lineColor":"#E1BEE7","lineWidth":"2"},"children":[{"parent":"223789477ed0","note":"","children":[],"id":"7b36d7180f38","title":"Context&nbsp;设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"223789477ed0","note":"class App extends React.Component {\n  render() {\n    return &lt;Toolbar theme=&quot;dark&quot; /&gt;;\n  }\n}\n\nfunction Toolbar(props) {\n  // Toolbar 组件接受一个额外的“theme”属性，然后传递给 ThemedButton 组件。\n  // 如果应用中每一个单独的按钮都需要知道 theme 的值，这会是件很麻烦的事，\n  // 因为必须将这个值层层传递所有组件。\n  return (\n    &lt;div&gt;\n      &lt;ThemedButton theme={props.theme} /&gt;\n    &lt;/div&gt;\n  );\n}\n\nclass ThemedButton extends React.Component {\n  render() {\n    return &lt;Button theme={this.props.theme} /&gt;;\n  }\n}","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[],"style":{"lineStype":{"lineType":"roundBroken","lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","bold":false,"font-style":"normal","italic":false},"id":"a16c6e5bcc2b","title":"举个例子，在下面的代码中，我们通过一个&nbsp;“theme”&nbsp;属性手动调整一个按钮组件的样式<br>","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"223789477ed0","note":"// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。\n// 为当前的 theme 创建一个 context（“light”为默认值）。\nconst ThemeContext = React.createContext(&#39;light&#39;);\nclass App extends React.Component {\n  render() {\n    // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。\n    // 无论多深，任何组件都能读取这个值。\n    // 在这个例子中，我们将 “dark” 作为当前的值传递下去。\n    return (\n      &lt;ThemeContext.Provider value=&quot;dark&quot;&gt;\n        &lt;Toolbar /&gt;\n      &lt;/ThemeContext.Provider&gt;\n    );\n  }\n}\n\n// 中间的组件再也不必指明往下传递 theme 了。\nfunction Toolbar() {\n  return (\n    &lt;div&gt;\n      &lt;ThemedButton /&gt;\n    &lt;/div&gt;\n  );\n}\n\nclass ThemedButton extends React.Component {\n  // 指定 contextType 读取当前的 theme context。\n  // React 会往上找到最近的 theme Provider，然后使用它的值。\n  // 在这个例子中，当前的 theme 值为 “dark”。\n  static contextType = ThemeContext;\n  render() {\n    return &lt;Button theme={this.context} /&gt;;\n  }\n}","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[],"style":{"lineStype":{"lineType":"roundBroken","lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","bold":false,"font-style":"normal","italic":false},"id":"092bfe8c5167","title":"使用&nbsp;context,&nbsp;我们可以避免通过中间元素传递&nbsp;props","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"2","text":"&#xe62a"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"font-style":"normal","border-radius":"5px","background-color":"#E1BEE7","lineStype":{"lineColor":"#E1BEE7","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#E1BEE7","lineWidth":"2"},"font-family":"微软雅黑","border-width":0,"border-style":"solid"},"id":"223789477ed0","title":"何时使用&nbsp;Context<br>"},{"parent":"root","lineStyle":{"lineColor":"#FFCDD2","lineWidth":"2"},"children":[{"parent":"21f97824d675","note":"","children":[],"id":"40362a812f37","title":"Context&nbsp;主要应用场景在于很多不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"21f97824d675","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[],"style":{"lineStype":{"lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","bold":false,"font-style":"normal","italic":false},"id":"05f4325be7ec","title":"如果你只是想避免层层传递一些属性，组件组合（component&nbsp;composition）有时候是一个比&nbsp;context&nbsp;更好的解决方案<br>","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"21f97824d675","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[],"style":{"lineStype":{"lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","bold":false,"font-style":"normal","italic":false},"id":"4de74619b7af","title":"但是，有的时候在组件树中很多不同层级的组件需要访问同样的一批数据。Context&nbsp;能让你将这些数据向组件树下所有的组件进行“广播”，所有的组件都能访问到这些数据，也能访问到后续的数据更新。使用&nbsp;context&nbsp;的通用的场景包括管理当前的&nbsp;locale，theme，或者一些缓存数据，这比替代方案要简单的多","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"2","text":"&#xe62a"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","font-style":"normal","border-radius":"5px","background-color":"#FFCDD2","lineStype":{"lineColor":"#FFCDD2","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#FFCDD2","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"font-family":"微软雅黑","border-width":"0px","border-style":"none"},"id":"21f97824d675","title":"使用前的考虑<br>"},{"parent":"root","lineStyle":{"lineColor":"#C8E6C9","lineWidth":"2"},"children":[{"parent":"50a78d122f0e","note":"","children":[],"id":"ceb62dc3354a","title":"因为&nbsp;context&nbsp;会使用参考标识（reference&nbsp;identity）来决定何时进行渲染，这里可能会有一些陷阱，当&nbsp;provider&nbsp;的父组件进行重渲染时，可能会在&nbsp;consumers&nbsp;组件中触发意外的渲染","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"50a78d122f0e","note":"class App extends React.Component {\n  render() {\n    return (\n      &lt;MyContext.Provider value={{something: &#39;something&#39;}}&gt;\n        &lt;Toolbar /&gt;\n      &lt;/MyContext.Provider&gt;\n    );\n  }\n}","children":[],"id":"123e6b15f806","title":"举个例子，当每一次&nbsp;Provider&nbsp;重渲染时，以下的代码会重渲染所有下面的&nbsp;consumers&nbsp;组件，因为&nbsp;value&nbsp;属性总是被赋值为新的对象<br>","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"50a78d122f0e","note":"class App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      value: {something: &#39;something&#39;},\n    };\n  }\n\n  render() {\n    return (\n      &lt;Provider value={this.state.value}&gt;\n        &lt;Toolbar /&gt;\n      &lt;/Provider&gt;\n    );\n  }\n}","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[],"style":{"lineStype":{"lineType":"roundBroken","lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","bold":false,"font-style":"normal","italic":false},"id":"2f13a36a0d6d","title":"为了防止这种情况，将&nbsp;value&nbsp;状态提升到父节点的&nbsp;state&nbsp;里","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"2","text":"&#xe62a"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","font-style":"normal","border-radius":"5px","background-color":"#C8E6C9","lineStype":{"lineColor":"#F57F17","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#C8E6C9","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"font-family":"微软雅黑","border-width":"0px","border-style":"none"},"id":"50a78d122f0e","title":"注意事项<br>"},{"parent":"root","lineStyle":{"lineColor":"#FFE0B2","lineWidth":"2"},"children":[{"parent":"072ee8e22b0c","note":"","children":[],"id":"5e5f1d695f41","title":"先前&nbsp;React&nbsp;使用实验性的&nbsp;context&nbsp;API&nbsp;运行，旧的&nbsp;API&nbsp;将会在所有&nbsp;16.x&nbsp;版本中得到支持，但用到它的应用应该迁移到新版本。过时的&nbsp;API&nbsp;将在未来的&nbsp;React&nbsp;版本中被移除","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"072ee8e22b0c","children":[{"parent":"3b8aabfdccc7","children":[],"id":"99e6a15190f2","title":"https://react.docschina.org/docs/legacy-context.html"}],"id":"3b8aabfdccc7","title":"阅读过时的&nbsp;context&nbsp;文档了解更多<br>","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"font-style":"normal","border-radius":"5px","background-color":"#FFE0B2","lineStype":{"lineColor":"#FFE0B2","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#FFE0B2","lineWidth":"2"},"font-family":"微软雅黑","border-width":0,"border-style":"solid"},"id":"072ee8e22b0c","title":"注意<br>"}],"root":true,"theme":"customise_7fd055efa78b","style":{"background-color":"#E57373","border-radius":"6px","color":"rgb(255, 255, 255)","font-weight":"bold","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"root","title":"Context","icons":[],"structure":"mind_free"}},"meta":{"exportTime":"2022-04-02 16:58:31","member":"60cca488e0b34d55bbf2954f","diagramInfo":{"creator":"60cca488e0b34d55bbf2954f","created":"2022-04-02 16:56:41","modified":"2022-04-02 16:58:06","title":"3.3.1Context","category":"mind_free"},"id":"62480fc91efad40756de8ef9","type":"ProcessOn Schema File","version":"1.0"}}