{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"note":"","watermark":"","children":[{"parent":"root","lineStyle":{"lineColor":"#FFCDD2","lineWidth":"2"},"children":[{"parent":"5bf8fe5c3c71","note":"","children":[],"id":"4b0af9a73e1a","title":"“render&nbsp;prop”&nbsp;是指一种在&nbsp;React&nbsp;组件之间使用一个值为函数的&nbsp;prop&nbsp;共享代码的简单技术","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"5bf8fe5c3c71","children":[{"parent":"b327245658d2","children":[],"style":{"background-color":"#F5F5F5","font-size":12},"id":"279b6892b1ff","title":"&lt;DataProvider&nbsp;render={data&nbsp;=&gt;&nbsp;(\n&nbsp;&nbsp;&lt;h1&gt;Hello&nbsp;{data.target}&lt;/h1&gt;\n)}/&gt;"}],"boundaries":[{"boundary":true,"parent":"b327245658d2","boundRank":1,"children":[],"pos":{"miny":9561,"minx":10651,"maxY":9633,"maxX":10876},"range":"0,0","style":{"lineType":"1","dasharray":"6,3","lineColor":"#bf1e1b","opacity":"0.1","fill":"#bf1e1b","lineWidth":"1"},"id":"124ec5dcd51c","title":"外框"}],"id":"b327245658d2","title":"具有&nbsp;render&nbsp;prop&nbsp;的组件接受一个函数，<br>该函数返回一个&nbsp;React&nbsp;元素并调用它而不是实现自己的渲染逻辑<br>","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"5bf8fe5c3c71","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[],"style":{"lineStype":{"lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","font-style":"normal"},"id":"19ebcaef8a05","title":"使用&nbsp;render&nbsp;prop&nbsp;的库有&nbsp;React&nbsp;Router、Downshift&nbsp;以及&nbsp;Formik。<br>下面将讨论为什么&nbsp;render&nbsp;prop&nbsp;是有用的，以及如何写一个自己的&nbsp;render&nbsp;prop&nbsp;组件","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"2","text":"&#xe62a"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","font-style":"normal","border-radius":"5px","background-color":"#FFCDD2","lineStype":{"lineColor":"#FFCDD2","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#FFCDD2","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"font-family":"微软雅黑","border-width":"0px","border-style":"none"},"id":"5bf8fe5c3c71","title":"介绍<br>"},{"parent":"root","lineStyle":{"lineColor":"#BBDEFB"},"children":[{"parent":"812b3a9306dd","note":"","children":[],"id":"ac25a09c6779","title":"使用&nbsp;Render&nbsp;Props&nbsp;来解决横切关注点","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"812b3a9306dd","children":[{"parent":"4d70d73dad33","children":[{"parent":"62ab4359781b","note":"class MouseTracker extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n    this.state = { x: 0, y: 0 };\n  }\n\n  handleMouseMove(event) {\n    this.setState({\n      x: event.clientX,\n      y: event.clientY\n    });\n  }\n\n  render() {\n    return (\n      &lt;div style={{ height: &#39;100vh&#39; }} onMouseMove={this.handleMouseMove}&gt;\n        &lt;h1&gt;移动鼠标!&lt;/h1&gt;\n        &lt;p&gt;当前的鼠标位置是 ({this.state.x}, {this.state.y})&lt;/p&gt;\n      &lt;/div&gt;\n    );\n  }\n}","children":[],"id":"883700095503","title":"代码"}],"style":{"font-size":12},"id":"62ab4359781b","title":"以下组件跟踪&nbsp;Web&nbsp;应用程序中的鼠标位置"},{"parent":"4d70d73dad33","note":"// &lt;Mouse&gt; 组件封装了我们需要的行为...\nclass Mouse extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n    this.state = { x: 0, y: 0 };\n  }\n\n  handleMouseMove(event) {\n    this.setState({\n      x: event.clientX,\n      y: event.clientY\n    });\n  }\n\n  render() {\n    return (\n      &lt;div style={{ height: &#39;100vh&#39; }} onMouseMove={this.handleMouseMove}&gt;\n\n        {/* ...但我们如何渲染 &lt;p&gt; 以外的东西? */}\n        &lt;p&gt;The current mouse position is ({this.state.x}, {this.state.y})&lt;/p&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nclass MouseTracker extends React.Component {\n  render() {\n    return (\n      &lt;&gt;\n        &lt;h1&gt;移动鼠标!&lt;/h1&gt;\n        &lt;Mouse /&gt;\n      &lt;/&gt;\n    );\n  }\n}","children":[],"style":{"font-size":12},"id":"9c6810f9e39a","title":"当光标在屏幕上移动时，组件在&nbsp;&lt;p&gt;&nbsp;中显示其（x，y）坐标。<br>现在的问题是：我们如何在另一个组件中复用这个行为？换个说法，<br>若另一个组件需要知道鼠标位置，我们能否封装这一行为，以便轻松地与其他组件共享它？？<br>由于组件是&nbsp;React&nbsp;中最基础的代码复用单元，现在尝试重构一部分代码使其能够在&nbsp;&lt;Mouse&gt;&nbsp;组件中封装我们需要共享的行为<br>"},{"parent":"4d70d73dad33","note":"class Cat extends React.Component {\n  render() {\n    const mouse = this.props.mouse;\n    return (\n      &lt;img src=&quot;/cat.jpg&quot; style={{ position: &#39;absolute&#39;, left: mouse.x, top: mouse.y }} /&gt;\n    );\n  }\n}\n\nclass MouseWithCat extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n    this.state = { x: 0, y: 0 };\n  }\n\n  handleMouseMove(event) {\n    this.setState({\n      x: event.clientX,\n      y: event.clientY\n    });\n  }\n\n  render() {\n    return (\n      &lt;div style={{ height: &#39;100vh&#39; }} onMouseMove={this.handleMouseMove}&gt;\n\n        {/*\n          我们可以在这里换掉 &lt;p&gt; 的 &lt;Cat&gt;   ......\n          但是接着我们需要创建一个单独的 &lt;MouseWithSomethingElse&gt;\n          每次我们需要使用它时，&lt;MouseWithCat&gt; 是不是真的可以重复使用.\n        */}\n        &lt;Cat mouse={this.state} /&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nclass MouseTracker extends React.Component {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;移动鼠标!&lt;/h1&gt;\n        &lt;MouseWithCat /&gt;\n      &lt;/div&gt;\n    );\n  }\n}","children":[],"style":{"font-size":12},"id":"f1e078c7c0c7","title":"现在&nbsp;&lt;Mouse&gt;&nbsp;组件封装了所有关于监听&nbsp;mousemove&nbsp;事件和存储鼠标&nbsp;(x,&nbsp;y)&nbsp;位置的行为，但其仍不是真正的可复用。<br>举个例子，假设我们有一个&nbsp;&lt;Cat&gt;&nbsp;组件，它可以呈现一张在屏幕上追逐鼠标的猫的图片。我们或许会使用&nbsp;&lt;Cat&nbsp;mouse={{&nbsp;x,&nbsp;y&nbsp;}}&nbsp;prop&nbsp;来告诉组件鼠标的坐标以让它知道图片应该在屏幕哪个位置。<br>首先,&nbsp;你或许会像这样，尝试在&nbsp;&lt;Mouse&gt;&nbsp;内部的渲染方法渲染&nbsp;&lt;Cat&gt;&nbsp;组件"},{"parent":"4d70d73dad33","note":"class Cat extends React.Component {\n  render() {\n    const mouse = this.props.mouse;\n    return (\n      &lt;img src=&quot;/cat.jpg&quot; style={{ position: &#39;absolute&#39;, left: mouse.x, top: mouse.y }} /&gt;\n    );\n  }\n}\n\nclass Mouse extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n    this.state = { x: 0, y: 0 };\n  }\n\n  handleMouseMove(event) {\n    this.setState({\n      x: event.clientX,\n      y: event.clientY\n    });\n  }\n\n  render() {\n    return (\n      &lt;div style={{ height: &#39;100vh&#39; }} onMouseMove={this.handleMouseMove}&gt;\n\n        {/*\n          Instead of providing a static representation of what &lt;Mouse&gt; renders,\n          use the `render` prop to dynamically determine what to render.\n        */}\n        {this.props.render(this.state)}\n      &lt;/div&gt;\n    );\n  }\n}\n\nclass MouseTracker extends React.Component {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;移动鼠标!&lt;/h1&gt;\n        &lt;Mouse render={mouse =&gt; (\n          &lt;Cat mouse={mouse} /&gt;\n        )}/&gt;\n      &lt;/div&gt;\n    );\n  }\n}","children":[],"style":{"font-size":12},"id":"59b820336f3a","title":"这种方法适用于我们的特定用例，但我们还没有达到以可复用的方式真正封装行为的目标。现在，每当我们想要鼠标位置用于不同的用例时，我们必须创建一个新的组件（本质上是另一个&nbsp;&lt;MouseWithCat&gt;&nbsp;），它专门为该用例呈现一些东西.<br>这也是&nbsp;render&nbsp;prop&nbsp;的来历：我们可以提供一个带有函数&nbsp;prop&nbsp;的&lt;Mouse&gt;组件，它能够动态决定什么需要渲染的，而不是将&nbsp;&lt;Cat&gt;&nbsp;硬编码到&nbsp;&lt;Mouse&gt;&nbsp;组件里，并有效地改变它的渲染结果"},{"parent":"4d70d73dad33","note":"// 如果你出于某种原因真的想要 HOC，那么你可以轻松实现\n// 使用具有 render prop 的普通组件创建一个！\nfunction withMouse(Component) {\n  return class extends React.Component {\n    render() {\n      return (\n        &lt;Mouse render={mouse =&gt; (\n          &lt;Component {...this.props} mouse={mouse} /&gt;\n        )}/&gt;\n      );\n    }\n  }\n}","children":[],"style":{"font-size":12},"id":"bcd0c6b99851","title":"现在，我们提供了一个&nbsp;render&nbsp;方法&nbsp;让&nbsp;&lt;Mouse&gt;&nbsp;能够动态决定什么需要渲染，而不是克隆&nbsp;&lt;Mouse&gt;&nbsp;组件然后硬编码来解决特定的用例。<br>更具体地说，render&nbsp;prop&nbsp;是一个用于告知组件需要渲染什么内容的函数&nbsp;prop。<br>这项技术使我们共享行为非常容易。要获得这个行为，只要渲染一个带有&nbsp;render&nbsp;prop&nbsp;的&nbsp;&lt;Mouse&gt;&nbsp;组件就能够告诉它当前鼠标坐标&nbsp;(x,&nbsp;y)&nbsp;要渲染什么。<br>关于&nbsp;render&nbsp;prop&nbsp;一个有趣的事情是你可以使用带有&nbsp;render&nbsp;prop&nbsp;的常规组件来实现大多数高阶组件&nbsp;(HOC)。&nbsp;例如，如果你更喜欢使用&nbsp;withMouse&nbsp;HOC而不是&nbsp;&lt;Mouse&gt;&nbsp;组件，你可以使用带有&nbsp;render&nbsp;prop&nbsp;的常规&nbsp;&lt;Mouse&gt;&nbsp;轻松创建一个"},{"parent":"4d70d73dad33","children":[],"style":{"font-size":12},"id":"1c6421d6412e","title":"因此，你可以将任一模式与&nbsp;render&nbsp;prop&nbsp;一起使用"}],"id":"4d70d73dad33","title":"例如","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]}],"style":{"background-color":"#BBDEFB","border-radius":"5px","color":"#212121","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"812b3a9306dd","title":"使用&nbsp;<br>Render&nbsp;Props&nbsp;<br>来解决横切关注点<br>"},{"parent":"root","lineStyle":{"lineColor":"#E1BEE7","lineWidth":"2"},"children":[{"parent":"896498dd7718","note":"","children":[],"id":"3c25c1c2ba10","title":"重要的是要记住，render&nbsp;prop&nbsp;是因为模式才被称为&nbsp;render&nbsp;prop&nbsp;，你不一定要用名为&nbsp;render&nbsp;的&nbsp;prop&nbsp;来使用这种模式。事实上，&nbsp;任何被用于告知组件需要渲染什么内容的函数&nbsp;prop&nbsp;在技术上都可以被称为&nbsp;“render&nbsp;prop”","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"896498dd7718","children":[],"id":"4be7280572a9","title":"记住，children&nbsp;prop&nbsp;并不真正需要添加到&nbsp;JSX&nbsp;元素的&nbsp;“attributes”&nbsp;列表中。相反，你可以直接放置到元素的内部<br>","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"896498dd7718","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[],"style":{"lineStype":{"lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","font-style":"normal"},"id":"d7a2018a01ad","title":"由于这一技术的特殊性，当你在设计一个类似的&nbsp;API&nbsp;时，你或许会要直接地在你的&nbsp;propTypes&nbsp;里声明&nbsp;children&nbsp;的类型应为一个函数","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"2","text":"&#xe62a"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"font-style":"normal","border-radius":"5px","background-color":"#E1BEE7","lineStype":{"lineColor":"#E1BEE7","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#E1BEE7","lineWidth":"2"},"font-family":"微软雅黑","border-width":0,"border-style":"solid"},"id":"896498dd7718","title":"使用&nbsp;Props&nbsp;<br>而非&nbsp;render<br>"},{"parent":"root","lineStyle":{"lineColor":"#FFE0B2","lineWidth":"2"},"children":[{"parent":"cecb23f7996e","note":"","children":[],"id":"10eb40fe09d6","title":"将&nbsp;Render&nbsp;Props&nbsp;与&nbsp;React.PureComponent&nbsp;一起使用时要小心","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"cecb23f7996e","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[],"style":{"lineStype":{"lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","font-style":"normal"},"id":"9e830d23e729","title":"如果你在&nbsp;render&nbsp;方法里创建函数，那么使用&nbsp;render&nbsp;prop&nbsp;会抵消使用&nbsp;React.PureComponent&nbsp;带来的优势。因为浅比较&nbsp;props&nbsp;的时候总会得到&nbsp;false，并且在这种情况下每一个&nbsp;render&nbsp;对于&nbsp;render&nbsp;prop&nbsp;将会生成一个新的值<br>","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"cecb23f7996e","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[{"parent":"3e27caf3cc77","note":"class MouseTracker extends React.Component {\n  // 定义为实例方法，`this.renderTheCat`始终\n  // 当我们在渲染中使用它时，它指的是相同的函数\n  renderTheCat(mouse) {\n    return &lt;Cat mouse={mouse} /&gt;;\n  }\n\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;Move the mouse around!&lt;/h1&gt;\n        &lt;Mouse render={this.renderTheCat} /&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n如果你无法静态定义 prop（例如，因为你需要关闭组件的 props 和/或 state），则 &lt;Mouse&gt; 应该扩展 React.Component。","children":[],"id":"a3400b430893","title":"类似这样"}],"style":{"lineStype":{"lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","font-style":"normal"},"id":"3e27caf3cc77","title":"为了绕过这一问题，有时你可以定义一个&nbsp;prop&nbsp;作为实例方法","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"2","text":"&#xe62a"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"font-style":"normal","border-radius":"5px","background-color":"#FFE0B2","lineStype":{"lineColor":"#FFE0B2","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#FFE0B2","lineWidth":"2"},"font-family":"微软雅黑","border-width":0,"border-style":"solid"},"id":"cecb23f7996e","title":"注意事项<br>"}],"root":true,"theme":"customise_7fd055efa78b","style":{"background-color":"#2196F3","border-radius":"6px","color":"rgb(255, 255, 255)","font-weight":"bold","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"root","title":"Render&nbsp;Props","icons":[],"structure":"mind_free"}},"meta":{"exportTime":"2022-04-08 18:04:40","member":"60cca488e0b34d55bbf2954f","diagramInfo":{"creator":"60cca488e0b34d55bbf2954f","created":"2022-04-08 17:50:47","modified":"2022-04-08 18:04:16","title":"3.17Render Props","category":"mind_free"},"id":"62500577f346fb1da673978f","type":"ProcessOn Schema File","version":"1.0"}}