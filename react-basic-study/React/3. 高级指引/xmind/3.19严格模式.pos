{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"note":"","margin":{"childMarginW":10,"childMarginH":5,"marginW":20,"marginH":10},"watermark":"","children":[{"parent":"root","lineStyle":{"randomLineColor":"rgb(255,204,204)","lineColor":"#7B1FA2"},"children":[{"parent":"812b3a9306dd","note":"","children":[],"id":"ac25a09c6779","title":"StrictMode&nbsp;是一个用来突出显示应用程序中潜在问题的工具。<br>与&nbsp;Fragment&nbsp;一样，StrictMode&nbsp;不会渲染任何可见的&nbsp;UI。它为其后代元素触发额外的检查和警告","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"812b3a9306dd","children":[{"parent":"4d70d73dad33","note":"import React from &#39;react&#39;;\n\nfunction ExampleApplication() {\n  return (\n    &lt;div&gt;\n      &lt;Header /&gt;\n      &lt;React.StrictMode&gt;\n        &lt;div&gt;\n          &lt;ComponentOne /&gt;\n          &lt;ComponentTwo /&gt;\n        &lt;/div&gt;\n      &lt;/React.StrictMode&gt;\n      &lt;Footer /&gt;\n    &lt;/div&gt;\n  );\n}\n\n在上述的示例中，不会对 Header 和 Footer 组件运行严格模式检查。但是，ComponentOne 和 ComponentTwo 以及它们的所有后代元素都将进行检查","children":[],"id":"40ddcb4f125b","title":"例如"}],"id":"4d70d73dad33","title":"你可以为应用程序的任何部分启用严格模式","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"812b3a9306dd","children":[{"parent":"c4c8ddf71cd2","children":[],"id":"41e9436a68a1","title":"识别不安全的生命周期"},{"parent":"c4c8ddf71cd2","children":[],"id":"ac0de592c351","title":"关于使用过时字符串&nbsp;ref&nbsp;API&nbsp;的警告"},{"parent":"c4c8ddf71cd2","children":[],"id":"e110feb24080","title":"关于使用废弃的&nbsp;findDOMNode&nbsp;方法的警告"},{"parent":"c4c8ddf71cd2","children":[],"id":"0a58e28b0d0e","title":"检测意外的副作用"},{"parent":"c4c8ddf71cd2","children":[],"id":"20485a9d50ef","title":"检测过时的&nbsp;context&nbsp;API"}],"id":"c4c8ddf71cd2","title":"StrictMode 有助于","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"2","text":"&#xe62a"}]}],"style":{"background-color":"#7B1FA2","border-radius":"5px","color":"rgb(255, 255, 255)","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"812b3a9306dd","title":"watch&nbsp;函数"},{"parent":"root","lineStyle":{"lineColor":"#1976D2","lineWidth":"2"},"children":[{"parent":"c723a9675abe","note":"","children":[],"id":"6c3908c4ee07","title":"某些过时的生命周期方法在异步&nbsp;React&nbsp;应用程序中使用是不安全的。但是，如果你的应用程序使用了第三方库，很难确保它们不使用这些生命周期方法。幸运的是，严格模式可以帮助解决这个问题！","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"c723a9675abe","children":[],"id":"a53c6f2ec719","title":"当启用严格模式时，React&nbsp;会列出使用了不安全生命周期方法的所有&nbsp;class&nbsp;组件，并打印一条包含这些组件信息的警告消息","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#F5F5F5","textAlign":"left","font-weight":"bold","font-size":13,"font-style":"normal","border-radius":"5px","background-color":"#1976D2","lineStype":{"lineColor":"#1976D2","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#1976D2","lineWidth":"2"},"font-family":"微软雅黑","border-width":0,"border-style":"solid"},"id":"c723a9675abe","title":"识别不安全的生命周期"},{"parent":"root","lineStyle":{"lineColor":"#388E3C","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"children":[{"parent":"a366ed307a4a","note":"","children":[],"id":"e63f6a4fdc87","title":"以前，React&nbsp;提供了两种方法管理&nbsp;refs&nbsp;的方式：已过时的字符串&nbsp;ref&nbsp;API&nbsp;的形式及回调函数&nbsp;API&nbsp;的形式。尽管字符串&nbsp;ref&nbsp;API&nbsp;在两者中使用更方便，但是它有一些缺点，因此官方推荐采用回调的方式。<br>","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"a366ed307a4a","note":"class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.inputRef = React.createRef();\n  }\n\n  render() {\n    return &lt;input type=&quot;text&quot; ref={this.inputRef} /&gt;;\n  }\n\n  componentDidMount() {\n    this.inputRef.current.focus();\n  }\n}","children":[],"id":"3d5836eb38b6","title":"React&nbsp;16.3&nbsp;新增了第三种选择，它提供了使用字符串&nbsp;ref&nbsp;的便利性，并且不存在任何缺点","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"a366ed307a4a","children":[],"id":"ea863005b56c","title":"由于对象&nbsp;ref&nbsp;主要是为了替换字符串&nbsp;ref&nbsp;而添加的，因此严格模式现在会警告使用字符串&nbsp;ref","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"2","text":"&#xe62a"}]},{"parent":"a366ed307a4a","children":[{"parent":"0e940a1850c1","children":[],"id":"fc56f690f398","title":"除了新增加的&nbsp;createRef&nbsp;API，回调&nbsp;ref&nbsp;依旧适用。<br>你无需替换组件中的回调&nbsp;ref。它们更灵活，因此仍将作为高级功能保留"}],"id":"0e940a1850c1","title":"注意","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"3","text":"&#xe635"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"rgb(255, 255, 255)","textAlign":"left","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","font-style":"normal","border-radius":"5px","background-color":"#388E3C","lineStype":{"lineColor":"#388E3C","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#388E3C","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"font-family":"微软雅黑","border-width":"0px","border-style":"none"},"id":"a366ed307a4a","title":"关于使用<br>过时字符串&nbsp;ref&nbsp;API&nbsp;<br>的警告"},{"parent":"root","lineStyle":{"lineColor":"#F57F17","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"children":[{"parent":"2a8881dc4152","note":"","children":[],"id":"d79e61d3727d","title":"React&nbsp;支持用&nbsp;findDOMNode&nbsp;来在给定&nbsp;class&nbsp;实例的情况下在树中搜索&nbsp;DOM&nbsp;节点。通常你不需要这样做，因为你可以将&nbsp;ref&nbsp;直接绑定到&nbsp;DOM&nbsp;节点","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"2a8881dc4152","children":[],"id":"39826500071d","title":"findDOMNode&nbsp;也可用于&nbsp;class&nbsp;组件，但它违反了抽象原则，它使得父组件需要单独渲染子组件。它会产生重构危险，你不能更改组件的实现细节，因为父组件可能正在访问它的&nbsp;DOM&nbsp;节点。findDOMNode&nbsp;只返回第一个子节点，但是使用&nbsp;Fragments，组件可以渲染多个&nbsp;DOM&nbsp;节点。findDOMNode&nbsp;是一个只读一次的&nbsp;API。调用该方法只会返回第一次查询的结果。如果子组件渲染了不同的节点，则无法跟踪此更改。因此，findDOMNode&nbsp;仅在组件返回单个且不可变的&nbsp;DOM&nbsp;节点时才有效","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"2a8881dc4152","note":"class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.wrapper = React.createRef();\n  }\n  render() {\n    return &lt;div ref={this.wrapper}&gt;{this.props.children}&lt;/div&gt;;\n  }\n}","children":[],"id":"68af52203073","title":"你可以通过将&nbsp;ref&nbsp;传递给自定义组件并使用&nbsp;ref&nbsp;转发来将其传递给&nbsp;DOM&nbsp;节点。<br>你也可以在组件中创建一个&nbsp;DOM&nbsp;节点的&nbsp;wrapper，并将&nbsp;ref&nbsp;直接绑定到它","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"2","text":"&#xe62a"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"rgb(255, 255, 255)","textAlign":"left","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","font-style":"normal","border-radius":"5px","background-color":"#F57F17","lineStype":{"lineColor":"#F57F17","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#F57F17","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"font-family":"微软雅黑","border-width":"0px","border-style":"none"},"id":"2a8881dc4152","title":"关于使用废弃的<br>findDOMNode&nbsp;方法<br>的警告"},{"parent":"root","lineStyle":{"lineColor":"#E57373","lineWidth":"2"},"children":[{"parent":"7f3589238824","note":"","children":[{"parent":"3bd1031e7793","children":[],"id":"6a5ef98535ff","title":"渲染&nbsp;阶段会确定需要进行哪些更改，比如&nbsp;DOM"},{"parent":"3bd1031e7793","children":[],"id":"6e583e73e488","title":"提交&nbsp;阶段发生在当&nbsp;React&nbsp;应用变化时"}],"id":"3bd1031e7793","title":"从概念上讲，React&nbsp;分两个阶段工作","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"7f3589238824","children":[],"id":"73b962c71b7e","title":"提交阶段通常会很快，但渲染过程可能很慢。因此，即将推出的&nbsp;concurrent&nbsp;模式&nbsp;(默认情况下未启用)&nbsp;将渲染工作分解为多个部分，对任务进行暂停和恢复操作以避免阻塞浏览器。这意味着&nbsp;React&nbsp;可以在提交之前多次调用渲染阶段生命周期的方法，或者在不提交的情况下调用它们","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"7f3589238824","children":[{"parent":"3753c9482f22","children":[],"id":"0de2d5c7a627","title":"constructor"},{"parent":"3753c9482f22","children":[],"id":"5420bccc34f7","title":"componentWillMount&nbsp;(or&nbsp;UNSAFE_componentWillMount)"},{"parent":"3753c9482f22","children":[],"id":"cf29533b293b","title":"componentWillReceiveProps&nbsp;(or&nbsp;UNSAFE_componentWillReceiveProps)"},{"parent":"3753c9482f22","children":[],"id":"49fbda3b1859","title":"componentWillUpdate&nbsp;(or&nbsp;UNSAFE_componentWillUpdate)"},{"parent":"3753c9482f22","children":[],"id":"0a9539b90b2b","title":"getDerivedStateFromProps"},{"parent":"3753c9482f22","children":[],"id":"6b7652db0c67","title":"shouldComponentUpdate"},{"parent":"3753c9482f22","children":[],"id":"b4be6f0f690f","title":"render"},{"parent":"3753c9482f22","children":[],"id":"a75e79b089ca","title":"setState&nbsp;更新函数（第一个参数）"}],"id":"3753c9482f22","title":"渲染阶段的生命周期<br>包括以下&nbsp;class&nbsp;组件方法：<br>","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"2","text":"&#xe62a"}]},{"parent":"7f3589238824","children":[],"id":"19f6c5233da8","title":"因为上述方法可能会被多次调用，所以不要在它们内部编写副作用相关的代码，这点非常重要。忽略此规则可能会导致各种问题的产生，包括内存泄漏和或出现无效的应用程序状态。不幸的是，这些问题很难被发现，因为它们通常具有非确定性","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"3","text":"&#xe635"}]},{"parent":"7f3589238824","children":[{"parent":"e43db036a67a","children":[],"id":"27126faa5206","title":"class&nbsp;组件的&nbsp;constructor，render&nbsp;以及&nbsp;shouldComponentUpdate&nbsp;方法"},{"parent":"e43db036a67a","children":[],"id":"6f3e3e34817c","title":"class&nbsp;组件的生命周期方法&nbsp;getDerivedStateFromProps"},{"parent":"e43db036a67a","children":[],"id":"4c6aa7553dea","title":"函数组件体"},{"parent":"e43db036a67a","children":[],"id":"5a8dafefcb58","title":"状态更新函数&nbsp;(即&nbsp;setState&nbsp;的第一个参数）"},{"parent":"e43db036a67a","children":[],"id":"d35b0cc74d30","title":"函数组件通过使用&nbsp;useState，useMemo&nbsp;或者&nbsp;useReducer"}],"id":"e43db036a67a","title":"严格模式不能自动检测到你的副作用，<br>但它可以帮助你发现它们，使它们更具确定性。<br>通过故意重复调用以下函数来实现的该操作","icons":[{"color":"rgb(48, 191, 191)","name":"priority","index":"4","text":"&#xe626"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#F5F5F5","textAlign":"left","font-weight":"bold","font-size":13,"font-style":"normal","border-radius":"5px","background-color":"#E57373","lineStype":{"lineColor":"#E57373","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#E57373","lineWidth":"2"},"font-family":"微软雅黑","border-width":0,"border-style":"solid"},"id":"7f3589238824","title":"检测意外的副作用"},{"parent":"root","lineStyle":{"lineColor":"#2196F3","lineWidth":"2"},"children":[{"parent":"e9477773125e","children":[],"id":"2603195149bf","title":"过时的&nbsp;context&nbsp;API&nbsp;容易出错，将在未来的主要版本中删除。在所有&nbsp;16.x&nbsp;版本中它仍然有效，但在严格模式下，将显示以下警告"}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#F5F5F5","textAlign":"left","font-weight":"bold","font-size":"14px","font-style":"normal","border-radius":"5px","lineStype":{"lineColor":"#2196F3","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#2196F3","lineWidth":"2"},"font-family":"微软雅黑","border-width":0,"border-style":"solid"},"id":"e9477773125e","title":"检测过时的&nbsp;<br>context&nbsp;API"}],"root":true,"theme":"customise_7fd055efa78b","style":{"font-weight":"bold"},"id":"root","title":"严格模式","icons":[{"color":"rgb(255, 255, 255)","name":"","index":"38"}],"structure":"mind_free"}},"meta":{"exportTime":"2022-04-08 23:14:45","member":"60cca488e0b34d55bbf2954f","diagramInfo":{"creator":"60cca488e0b34d55bbf2954f","created":"2022-04-08 23:01:47","modified":"2022-04-08 23:14:19","title":"3.19严格模式","category":"mind_free"},"id":"62504e5ae401fd072efe3a46","type":"ProcessOn Schema File","version":"1.0"}}