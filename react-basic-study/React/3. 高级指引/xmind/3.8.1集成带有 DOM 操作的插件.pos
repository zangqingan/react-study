{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"note":"","margin":{"childMarginW":10,"childMarginH":5,"marginW":20,"marginH":10},"watermark":"","children":[{"parent":"root","lineStyle":{"randomLineColor":"rgb(255,204,204)","lineColor":"#F44336"},"children":[{"parent":"812b3a9306dd","note":"","children":[],"style":{"font-weight":"normal"},"id":"ac25a09c6779","title":"React&nbsp;不会理会&nbsp;React&nbsp;自身之外的&nbsp;DOM&nbsp;操作。它根据内部虚拟&nbsp;DOM&nbsp;来决定是否需要更新，而且如果同一个&nbsp;DOM&nbsp;节点被另一个库操作了，React&nbsp;会觉得困惑而且没有办法恢复。<br>这并不意味着&nbsp;React&nbsp;与其他操作&nbsp;DOM&nbsp;的方式不能结合，也不一定结合困难，只不过需要你去关注每个库所做的事情。<br>","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0"}]},{"parent":"812b3a9306dd","children":[],"id":"53f5d469c294","title":"避免冲突的最简单方式就是防止&nbsp;React&nbsp;组件更新。你可以渲染无需更新的&nbsp;React&nbsp;元素，比如一个空的&nbsp;&lt;div&nbsp;/&gt;","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"1"}]}],"style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"812b3a9306dd","title":"介绍"},{"parent":"root","lineStyle":{"lineColor":"#1976D2"},"children":[{"parent":"3b7f7da9d693","note":"class SomePlugin extends React.Component {\n  componentDidMount() {\n    this.$el = $(this.el);\n    this.$el.somePlugin();\n  }\n\n  componentWillUnmount() {\n    this.$el.somePlugin(&#39;destroy&#39;);\n  }\n\n  render() {\n    return &lt;div ref={el =&gt; this.el = el} /&gt;;\n  }\n}","children":[],"id":"ea17cb43a15a","title":"为了证明这一点，我来草拟一个用于通用&nbsp;jQuery&nbsp;插件的&nbsp;wrapper<br>我们会添加一个&nbsp;ref&nbsp;到这个根&nbsp;DOM&nbsp;元素。&nbsp;在&nbsp;componentDidMount&nbsp;中，我们能够获取它的引用这样我们就可以把它传递给&nbsp;jQuery&nbsp;插件了。<br>为了防止&nbsp;React&nbsp;在挂载之后去触碰这个&nbsp;DOM，我们会从&nbsp;render()&nbsp;函数返回一个空的&nbsp;&lt;div&nbsp;/&gt;。这个&nbsp;&lt;div&nbsp;/&gt;&nbsp;元素既没有属性也没有子元素，所以&nbsp;React&nbsp;没有理由去更新它，使得&nbsp;jQuery&nbsp;插件可以自由的管理这部分的&nbsp;DOM","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0"}]},{"parent":"3b7f7da9d693","children":[],"id":"ceea86319f3a","title":"注意我们同时定义了&nbsp;componentDidMount&nbsp;和&nbsp;componentWillUnmount&nbsp;生命周期函数。许多&nbsp;jQuery&nbsp;插件绑定事件监听到&nbsp;DOM&nbsp;上，所以在&nbsp;componentWillUnmount&nbsp;中注销监听是很重要的。如果这个插件没有提供一个用于清理的方法，你很可能会需要自己来提供一个，为了避免内存泄漏要记得把所有插件注册的监听都移除掉","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"1"}]}],"boundaries":[],"style":{"background-color":"#1976D2","border-radius":"5px","font-weight":"bold","font-size":13},"id":"3b7f7da9d693","title":"如何解决这个问题"},{"parent":"root","lineStyle":{"randomLineColor":"rgb(153,204,255)","lineColor":"#F57F17"},"children":[{"parent":"b653f7534587","note":"function Example() {\n  return (\n    &lt;Chosen onChange={value =&gt; console.log(value)}&gt;\n      &lt;option&gt;vanilla&lt;/option&gt;\n      &lt;option&gt;chocolate&lt;/option&gt;\n      &lt;option&gt;strawberry&lt;/option&gt;\n    &lt;/Chosen&gt;\n  );\n}","children":[],"id":"34981260374f","title":"对于应用这些概念的更具体的一个例子，我们给这个用于增强&nbsp;&lt;select&gt;&nbsp;输入的&nbsp;Chosen&nbsp;插件写一个最小的&nbsp;wrapper<br>首先，我们来看下&nbsp;Chosen&nbsp;对&nbsp;DOM&nbsp;做了哪些操作<br>如果你在一个&nbsp;&lt;select&gt;&nbsp;DOM&nbsp;节点上调用了它，它会读取原&nbsp;DOM&nbsp;节点的属性，使用行内样式隐藏它，然后紧挨着这个&nbsp;&lt;select&gt;&nbsp;之后增加一个独立的具有它自身显示表现的&nbsp;DOM&nbsp;节点。然后它会在值变化的时候触发&nbsp;jQuery&nbsp;事件来通知我们这些变化。<br>以下代码是我们最终要实现的效果<br>","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0"}]},{"parent":"b653f7534587","note":"class Chosen extends React.Component {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;select className=&quot;Chosen-select&quot; ref={el =&gt; this.el = el}&gt;\n          {this.props.children}\n        &lt;/select&gt;\n      &lt;/div&gt;\n    );\n  }\n}","children":[],"id":"aa2d3e833aa4","title":"为了简化，我们将它实现为&nbsp;uncontrolled&nbsp;component<br>首先，我会创建一个空的组件，它的&nbsp;render()&nbsp;函数我们返回一个包含&nbsp;&lt;select&gt;&nbsp;的&nbsp;&lt;div&gt;","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"1"}]},{"parent":"b653f7534587","note":"componentDidMount() {\n  this.$el = $(this.el);\n  this.$el.chosen();\n}\n\ncomponentWillUnmount() {\n  this.$el.chosen(&#39;destroy&#39;);\n}","children":[],"id":"5c1487a6bcf3","title":"注意我们为什么要把&nbsp;&lt;select&gt;&nbsp;使用一个额外的&nbsp;&lt;div&gt;&nbsp;包裹起来。这是很必要的，因为&nbsp;Chosen&nbsp;会紧挨着我们传递给它的&nbsp;&lt;select&gt;&nbsp;节点追加另一个&nbsp;DOM&nbsp;元素。然而，对于&nbsp;React&nbsp;来说&nbsp;&lt;div&gt;&nbsp;总是只有一个子节点。这样我们就能确保&nbsp;React&nbsp;更新不会和&nbsp;Chosen&nbsp;追加的额外&nbsp;DOM&nbsp;节点发生冲突。在&nbsp;React&nbsp;工作流之外修改&nbsp;DOM&nbsp;是非常重大的事情，你必须确保&nbsp;React&nbsp;没有理由去触碰那些节点。<br>接下来，我们会实现生命周期函数。我们需要在&nbsp;componentDidMount&nbsp;中使用&nbsp;&lt;select&gt;&nbsp;的引用初始化&nbsp;Chosen，并且在&nbsp;componentWillUnmount&nbsp;中将其销毁","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"2"}]},{"parent":"b653f7534587","note":"&lt;select className=&quot;Chosen-select&quot; ref={el =&gt; this.el = el}&gt;","children":[],"id":"ac89e4eb3384","title":"注意&nbsp;React&nbsp;不会给&nbsp;this.el&nbsp;字段赋予特殊的含义。它能够工作只是因为我们之前在&nbsp;render()&nbsp;函数中把一个&nbsp;ref&nbsp;赋值给了这个字段","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"3"}]},{"parent":"b653f7534587","note":"componentDidMount() {\n  this.$el = $(this.el);\n  this.$el.chosen();\n\n  this.handleChange = this.handleChange.bind(this);\n  this.$el.on(&#39;change&#39;, this.handleChange);\n}\n\ncomponentWillUnmount() {\n  this.$el.off(&#39;change&#39;, this.handleChange);\n  this.$el.chosen(&#39;destroy&#39;);\n}\n\nhandleChange(e) {\n  this.props.onChange(e.target.value);\n}","children":[],"id":"ea73561b243d","title":"到此已经足够让我们的组件去渲染了，但我们同时希望在值变化的时候被通知到。要做到这点，我们需要在订阅由&nbsp;Chosen&nbsp;管理的&nbsp;&lt;select&gt;&nbsp;上的&nbsp;jQuery&nbsp;change&nbsp;事件。<br>我们不直接把&nbsp;this.props.onChange&nbsp;传递给&nbsp;Chosen&nbsp;是因为组件的&nbsp;props&nbsp;可能随时变化，并且这也包括事件处理函数。对应的，我们会定义一个&nbsp;handleChange()&nbsp;方法来调用&nbsp;this.props.onChange，并且订阅&nbsp;jQuery&nbsp;的&nbsp;change&nbsp;事件","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"4"}]},{"parent":"b653f7534587","note":"componentDidUpdate(prevProps) {\n  if (prevProps.children !== this.props.children) {\n    this.$el.trigger(&quot;chosen:updated&quot;);\n  }\n}\n","children":[],"id":"48310f9c926a","title":"最后，还剩下一件事情需要处理。在&nbsp;React&nbsp;中，props&nbsp;可以在不同的时间有不同的值。例如，如果父组件的状态发生变化&nbsp;&lt;Chosen&gt;&nbsp;组件可能得到不同的&nbsp;children。这意味着从集成的角度来看，我们因应&nbsp;prop&nbsp;的更新而手动更新&nbsp;DOM&nbsp;这一点是非常重要的，因为我们已经不再使用&nbsp;React&nbsp;来帮我们管理&nbsp;DOM&nbsp;了。<br>Chosen&nbsp;的文档建议我们使用&nbsp;jQuery&nbsp;trigger()&nbsp;API&nbsp;来通知原始&nbsp;DOM&nbsp;元素这些变化。我们会让&nbsp;React来管理在&nbsp;&lt;select&gt;&nbsp;中&nbsp;this.props.children&nbsp;的更新，但是我们同样需要增加一个&nbsp;componentDidUpdate()&nbsp;生命周期函数来通知&nbsp;Chosen&nbsp;关于&nbsp;children&nbsp;列表的变化","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"5"}]},{"parent":"b653f7534587","children":[],"id":"34f92006f7f2","title":"通过这种方法，当由&nbsp;React&nbsp;管理的&nbsp;&lt;select&gt;&nbsp;children&nbsp;改变时，&nbsp;Chosen&nbsp;会知道如何更新它的&nbsp;DOM&nbsp;元素","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"6"}]}],"style":{"background-color":"#F57F17","border-radius":"5px","color":"rgb(255, 255, 255)","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"b653f7534587","title":"集成jQuery&nbsp;Chosen&nbsp;插件"}],"root":true,"theme":"customise_7fd055efa78b","style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","font-weight":"bold","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"root","title":"集成带有&nbsp;DOM&nbsp;操作的插件","icons":[{"color":"rgb(255, 255, 255)","name":"","index":"61"}],"structure":"mind_free"}},"meta":{"exportTime":"2022-04-06 17:59:12","member":"60cca488e0b34d55bbf2954f","diagramInfo":{"creator":"60cca488e0b34d55bbf2954f","created":"2022-04-06 17:45:32","modified":"2022-04-06 17:58:41","title":"3.8与第三方库协同","category":"mind_free"},"id":"624d613c079129641e4212df","type":"ProcessOn Schema File","version":"1.0"}}