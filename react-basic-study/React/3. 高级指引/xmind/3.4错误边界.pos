{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"note":"","margin":{"childMarginW":10,"childMarginH":5,"marginW":20,"marginH":10},"watermark":"","children":[{"parent":"root","lineStyle":{"randomLineColor":"rgb(255,204,204)","lineColor":"#E57373"},"children":[{"parent":"812b3a9306dd","note":"","children":[],"id":"ac25a09c6779","title":"部分&nbsp;UI&nbsp;的&nbsp;JavaScript&nbsp;错误不应该导致整个应用崩溃，为了解决这个问题，React&nbsp;16&nbsp;引入了一个新的概念&nbsp;——&nbsp;错误边界","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"812b3a9306dd","children":[],"id":"4d70d73dad33","title":"错误边界是一种&nbsp;React&nbsp;组件，这种组件可以捕获并打印发生在其子组件树任何位置的&nbsp;JavaScript&nbsp;错误，并且，它会渲染出备用&nbsp;UI，而不是渲染那些崩溃了的子组件树。错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"812b3a9306dd","children":[{"parent":"c4c8ddf71cd2","children":[],"id":"faa0eccbc453","title":"事件处理"},{"parent":"c4c8ddf71cd2","children":[],"id":"ed168914dc6a","title":"异步代码"},{"parent":"c4c8ddf71cd2","children":[],"id":"a1a773de46f5","title":"服务端渲染<br>"},{"parent":"c4c8ddf71cd2","children":[],"id":"0880364daf26","title":"它自身抛出来的错误"}],"id":"c4c8ddf71cd2","title":"注意，错误边界无法捕获以下场景中产生的错误：","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"2","text":"&#xe62a"}]},{"parent":"812b3a9306dd","children":[{"parent":"0ea413d23ee5","note":"class ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    // 更新 state 使下一次渲染能够显示降级后的 UI\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // 你同样可以将错误日志上报给服务器\n    logErrorToMyService(error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // 你可以自定义降级后的 UI 并渲染\n      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;\n    }\n\n    return this.props.children; \n  }\n}","children":[],"id":"7d28d4e98216","title":"如果一个&nbsp;class&nbsp;组件中定义了&nbsp;static&nbsp;getDerivedStateFromError()&nbsp;或&nbsp;componentDidCatch()&nbsp;这两个生命周期方法中的任意一个（或两个）时，那么它就变成一个错误边界。当抛出错误后，请使用&nbsp;static&nbsp;getDerivedStateFromError()&nbsp;渲染备用&nbsp;UI&nbsp;，使用&nbsp;componentDidCatch()&nbsp;打印错误信息"},{"parent":"0ea413d23ee5","children":[{"parent":"0edfa0fa28d9","note":"&lt;ErrorBoundary&gt;\n  &lt;MyWidget /&gt;\n&lt;/ErrorBoundary&gt;","children":[],"id":"dfe88071967b","title":"代码"}],"id":"0edfa0fa28d9","title":"然后你可以将它作为一个常规组件去使用"}],"id":"0ea413d23ee5","title":"例如","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"3","text":"&#xe635"}]},{"parent":"812b3a9306dd","children":[],"id":"ecbdb512a1c7","title":"错误边界的工作方式类似于&nbsp;JavaScript&nbsp;的&nbsp;catch&nbsp;{}，不同的地方在于错误边界只针对&nbsp;React&nbsp;组件。只有&nbsp;class&nbsp;组件才可以成为错误边界组件。大多数情况下,&nbsp;你只需要声明一次错误边界组件,&nbsp;并在整个应用中使用它。<br>注意错误边界仅可以捕获其子组件的错误，它无法捕获其自身的错误。如果一个错误边界无法渲染错误信息，则错误会冒泡至最近的上层错误边界，这也类似于&nbsp;JavaScript&nbsp;中&nbsp;catch&nbsp;{}&nbsp;的工作机制","icons":[{"color":"rgb(48, 191, 191)","name":"priority","index":"4","text":"&#xe626"}]},{"parent":"812b3a9306dd","children":[{"parent":"0eca8eb21aa9","children":[],"id":"80bf82ff8c6b","title":"React&nbsp;15&nbsp;中有一个支持有限的错误边界方法&nbsp;unstable_handleError。此方法不再起作用，同时自&nbsp;React&nbsp;16&nbsp;beta&nbsp;发布起你需要在代码中将其修改为&nbsp;componentDidCatch。<br>对此，我们已提供了一个&nbsp;codemod&nbsp;来帮助你自动迁移你的代码"}],"id":"0eca8eb21aa9","title":"自&nbsp;React&nbsp;15&nbsp;的命名更改"}],"style":{"background-color":"#E57373","border-radius":"5px","color":"rgb(255, 255, 255)","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"812b3a9306dd","title":"错误边界"},{"parent":"root","lineStyle":{"lineColor":"#1976D2","lineWidth":"2"},"children":[{"parent":"c723a9675abe","children":[],"id":"504826074ade","title":"错误边界的粒度由你来决定，可以将其包装在最顶层的路由组件并为用户展示一个&nbsp;“Something&nbsp;went&nbsp;wrong”&nbsp;的错误信息，就像服务端框架经常处理崩溃一样。你也可以将单独的部件包装在错误边界以保护应用其他部分不崩溃"}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#F5F5F5","textAlign":"left","font-weight":"bold","font-size":13,"font-style":"normal","border-radius":"5px","background-color":"#1976D2","lineStype":{"lineColor":"#1976D2","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#1976D2","lineWidth":"2"},"font-family":"微软雅黑","border-width":0,"border-style":"solid"},"id":"c723a9675abe","title":"放置在哪？"},{"parent":"root","lineStyle":{"lineColor":"#388E3C","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"children":[{"parent":"a366ed307a4a","note":"","children":[],"id":"e63f6a4fdc87","title":"这一改变具有重要意义，自&nbsp;React&nbsp;16&nbsp;起，任何未被错误边界捕获的错误将会导致整个&nbsp;React&nbsp;组件树被卸载","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"a366ed307a4a","children":[],"id":"3d5836eb38b6","title":"我们对这一决定有过一些争论，但根据经验，把一个错误的&nbsp;UI&nbsp;留在那比完全移除它要更糟糕。例如，在类似&nbsp;Messenger&nbsp;的产品中，把一个异常的&nbsp;UI&nbsp;展示给用户可能会导致用户将信息错发给别人。同样，对于支付类应用而言，显示错误的金额也比不呈现任何内容更糟糕。<br>此变化意味着当你迁移到&nbsp;React&nbsp;16&nbsp;时，可能会发现一些已存在你应用中但未曾注意到的崩溃。增加错误边界能够让你在应用发生异常时提供更好的用户体验","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"a366ed307a4a","children":[],"id":"ea863005b56c","title":"我们也鼓励使用&nbsp;JS&nbsp;错误报告服务（或自行构建），这样你能了解关于生产环境中出现的未捕获异常，并将其修复","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"2","text":"&#xe62a"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"rgb(255, 255, 255)","textAlign":"left","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","font-style":"normal","border-radius":"5px","background-color":"#388E3C","lineStype":{"lineColor":"#388E3C","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#388E3C","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"font-family":"微软雅黑","border-width":"0px","border-style":"none"},"id":"a366ed307a4a","title":"未捕获错误的新行为"},{"parent":"root","lineStyle":{"lineColor":"#F57F17","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"children":[{"parent":"2a8881dc4152","note":"","children":[],"id":"d79e61d3727d","title":"在开发环境下，React&nbsp;16&nbsp;会把渲染期间发生的所有错误打印到控制台，即使该应用意外的将这些错误掩盖。除了错误信息和&nbsp;JavaScript&nbsp;栈外，React&nbsp;16&nbsp;还提供了组件栈追踪。现在你可以准确地查看发生在组件树内的错误信息","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"2a8881dc4152","children":[],"id":"39826500071d","title":"你也可以在组件栈追踪中查看文件名和行号，这一功能在&nbsp;Create&nbsp;React&nbsp;App&nbsp;项目中默认开启","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"2a8881dc4152","children":[],"id":"68af52203073","title":"如果你没有使用&nbsp;Create&nbsp;React&nbsp;App，可以手动将该插件添加到你的&nbsp;Babel&nbsp;配置中。注意它仅用于开发环境，在生产环境必须将其禁用","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"2","text":"&#xe62a"}]},{"parent":"2a8881dc4152","children":[],"id":"133861172d71","title":"组件名称在栈追踪中的显示依赖于&nbsp;Function.name&nbsp;属性。如果你想要支持尚未提供该功能的旧版浏览器和设备（例如&nbsp;IE&nbsp;11），考虑在你的打包（bundled）应用程序中包含一个&nbsp;Function.name&nbsp;的&nbsp;polyfill，如&nbsp;function.name-polyfill&nbsp;。或者，你可以在所有组件上显式设置&nbsp;displayName&nbsp;属性","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"3","text":"&#xe635"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"rgb(255, 255, 255)","textAlign":"left","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","font-style":"normal","border-radius":"5px","background-color":"#F57F17","lineStype":{"lineColor":"#F57F17","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#F57F17","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"font-family":"微软雅黑","border-width":"0px","border-style":"none"},"id":"2a8881dc4152","title":"组件栈追踪"},{"parent":"root","lineStyle":{"lineColor":"#E57373","lineWidth":"2"},"children":[{"parent":"7f3589238824","note":"","children":[],"id":"3bd1031e7793","title":"try&nbsp;/&nbsp;catch&nbsp;很棒但它仅能用于命令式代码，然而，React&nbsp;组件是声明式的并且具体指出&nbsp;什么&nbsp;需要被渲染","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"7f3589238824","children":[],"id":"73b962c71b7e","title":"错误边界保留了&nbsp;React&nbsp;的声明性质，其行为符合你的预期。例如，即使一个错误发生在&nbsp;componentDidUpdate&nbsp;方法中，并且由某一个深层组件树的&nbsp;setState&nbsp;引起，其仍然能够冒泡到最近的错误边界","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#F5F5F5","textAlign":"left","font-weight":"bold","font-size":13,"font-style":"normal","border-radius":"5px","background-color":"#E57373","lineStype":{"lineColor":"#E57373","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#E57373","lineWidth":"2"},"font-family":"微软雅黑","border-width":0,"border-style":"solid"},"id":"7f3589238824","title":"try/catch"},{"parent":"root","lineStyle":{"lineColor":"#2196F3","lineWidth":"2"},"children":[{"parent":"e9477773125e","note":"","children":[],"id":"c4151b2c2cc2","title":"错误边界无法捕获事件处理器内部的错误","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"e9477773125e","children":[],"id":"f46d353ad051","title":"React&nbsp;不需要错误边界来捕获事件处理器中的错误。与&nbsp;render&nbsp;方法和生命周期方法不同，事件处理器不会在渲染期间触发。因此，如果它们抛出异常，React&nbsp;仍然能够知道需要在屏幕上显示什么。<br>如果你需要在事件处理器内部捕获错误，使用普通的&nbsp;JavaScript&nbsp;try&nbsp;/&nbsp;catch&nbsp;语句","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#F5F5F5","textAlign":"left","font-weight":"bold","font-size":"14px","font-style":"normal","border-radius":"5px","lineStype":{"lineColor":"#2196F3","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#2196F3","lineWidth":"2"},"font-family":"微软雅黑","border-width":0,"border-style":"solid"},"id":"e9477773125e","title":"事件处理器"}],"root":true,"theme":"customise_7fd055efa78b","style":{"font-weight":"bold"},"id":"root","title":"错误边界","icons":[{"color":"rgb(255, 255, 255)","name":"","index":"42"}],"structure":"mind_free"}},"meta":{"exportTime":"2022-04-06 16:37:20","member":"60cca488e0b34d55bbf2954f","diagramInfo":{"creator":"60cca488e0b34d55bbf2954f","created":"2022-04-06 16:02:04","modified":"2022-04-06 16:36:57","title":"3.4错误边界","category":"mind_free"},"id":"624d48fc637689075c5d8078","type":"ProcessOn Schema File","version":"1.0"}}