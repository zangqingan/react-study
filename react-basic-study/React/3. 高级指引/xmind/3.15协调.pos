{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"note":"","watermark":"","children":[{"parent":"root","lineStyle":{"lineColor":"#BBDEFB"},"children":[{"parent":"812b3a9306dd","note":"","children":[],"id":"ac25a09c6779","title":"React&nbsp;提供的声明式&nbsp;API&nbsp;让开发者可以在对&nbsp;React&nbsp;的底层实现没有具体了解的情况下编写应用。<br>在开发者编写应用时虽然保持相对简单的心智，但开发者无法了解内部的实现机制","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"812b3a9306dd","children":[],"id":"4d70d73dad33","title":"下面描述了在实现&nbsp;React&nbsp;的&nbsp;“diffing”&nbsp;算法中我们做出的设计决策以保证组件满足更新具有可预测性，以及在繁杂业务下依然保持应用的高性能性","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]}],"style":{"background-color":"#BBDEFB","border-radius":"5px","color":"#212121","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"812b3a9306dd","title":"介绍<br>"},{"parent":"root","lineStyle":{"lineColor":"#E1BEE7","lineWidth":"2"},"children":[{"parent":"896498dd7718","note":"","children":[],"id":"3c25c1c2ba10","title":"在某一时间节点调用&nbsp;React&nbsp;的&nbsp;render()&nbsp;方法，会创建一棵由&nbsp;React&nbsp;元素组成的树。在下一次&nbsp;state&nbsp;或&nbsp;props&nbsp;更新时，相同的&nbsp;render()&nbsp;方法会返回一棵不同的树。React&nbsp;需要基于这两棵树之间的差别来判断如何有效率的更新&nbsp;UI&nbsp;以保证当前&nbsp;UI&nbsp;与最新的树保持同步<br>","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"896498dd7718","children":[],"id":"4be7280572a9","title":"这个算法问题有一些通用的解决方案，即生成将一棵树转换成另一棵树的最小操作数。&nbsp;<br>然而，即使在最前沿的算法中，该算法的复杂程度为&nbsp;O(n&nbsp;3&nbsp;)，其中&nbsp;n&nbsp;是树中元素的数量<br>","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"896498dd7718","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[],"style":{"lineStype":{"lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","font-style":"normal"},"id":"d7a2018a01ad","title":"如果在&nbsp;React&nbsp;中使用了该算法，那么展示&nbsp;1000&nbsp;个元素所需要执行的计算量将在十亿的量级范围。这个开销实在是太过高昂。<br>","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"2","text":"&#xe62a"}]},{"parent":"896498dd7718","children":[{"parent":"0e4e1cbc9688","children":[],"id":"7a0f4fd902d0","title":"两个不同类型的元素会产生出不同的树；"},{"parent":"0e4e1cbc9688","children":[],"id":"36bb5b25a57e","title":"开发者可以通过&nbsp;key&nbsp;prop&nbsp;来暗示哪些子元素在不同的渲染下能保持稳定；"}],"id":"0e4e1cbc9688","title":"于是&nbsp;React&nbsp;在以下两个假设的基础之上提出了一套&nbsp;O(n)&nbsp;的启发式算法","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"3","text":"&#xe635"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"font-style":"normal","border-radius":"5px","background-color":"#E1BEE7","lineStype":{"lineColor":"#E1BEE7","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#E1BEE7","lineWidth":"2"},"font-family":"微软雅黑","border-width":0,"border-style":"solid"},"id":"896498dd7718","title":"设计动力<br>"},{"parent":"root","lineStyle":{"lineColor":"#FFCDD2","lineWidth":"2"},"children":[{"parent":"5bf8fe5c3c71","note":"","children":[{"parent":"4b0af9a73e1a","children":[],"id":"d92fedf80c12","title":"当根节点为不同类型的元素时，React&nbsp;会拆卸原有的树并且建立起新的树"},{"parent":"4b0af9a73e1a","children":[],"id":"eab672b296db","title":"当拆卸一棵树时，对应的&nbsp;DOM&nbsp;节点也会被销毁。组件实例将执行&nbsp;componentWillUnmount()&nbsp;方法。<br>当建立一棵新的树时，对应的&nbsp;DOM&nbsp;节点会被创建以及插入到&nbsp;DOM&nbsp;中。<br>组件实例将执行&nbsp;componentWillMount()&nbsp;方法，紧接着&nbsp;componentDidMount()&nbsp;方法。所有跟之前的树所关联的&nbsp;state&nbsp;也会被销毁"},{"parent":"4b0af9a73e1a","children":[],"id":"a7e96ffad8ce","title":"在根节点以下的组件也会被卸载，它们的状态会被销毁"}],"style":{"background-color":"rgb(255, 255, 255)","border-radius":"20px","color":"rgb(242, 154, 102)","border-color":"rgb(242, 154, 102)","border-width":"2px","border-style":"solid"},"id":"4b0af9a73e1a","title":"比对不同类型的元素","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"5bf8fe5c3c71","children":[{"parent":"b327245658d2","children":[],"id":"0b1125f96ab0","title":"当比对两个相同类型的&nbsp;React&nbsp;元素时，React&nbsp;会保留&nbsp;DOM&nbsp;节点，仅比对及更新有改变的属性"},{"parent":"b327245658d2","children":[],"id":"8e44230d53c2","title":"在处理完当前节点之后，React&nbsp;继续对子节点进行递归"}],"style":{"background-color":"rgb(255, 255, 255)","border-radius":"20px","color":"rgb(242, 154, 102)","border-color":"rgb(242, 154, 102)","border-width":"2px","border-style":"solid"},"id":"b327245658d2","title":"比对同一类型的元素<br>","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"5bf8fe5c3c71","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[{"parent":"19ebcaef8a05","children":[],"id":"b952451ee110","title":"当一个组件更新时，组件实例保持不变，这样&nbsp;state&nbsp;在跨越不同的渲染时保持一致。<br>React&nbsp;将更新该组件实例的&nbsp;props&nbsp;以跟最新的元素保持一致，并且调用该实例的&nbsp;componentWillReceiveProps()&nbsp;和&nbsp;componentWillUpdate()&nbsp;方法"},{"parent":"19ebcaef8a05","children":[],"id":"322f80d100c3","title":"下一步，调用&nbsp;render()&nbsp;方法，diff&nbsp;算法将在之前的结果以及新的结果中进行递归"}],"style":{"padding":"2px 8px 2px 8px","color":"rgb(242, 154, 102)","textAlign":"left","font-weight":"normal","font-size":"13px","border-color":"rgb(242, 154, 102)","font-style":"normal","lineStype":{"lineColor":"#555","lineWidth":1},"background-color":"rgb(255, 255, 255)","border-radius":"20px","lineStyle":{"lineColor":"#555","lineWidth":1},"font-family":"微软雅黑","border-width":"2px","border-style":"solid"},"id":"19ebcaef8a05","title":"比对同类型的组件元素","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"2","text":"&#xe62a"}]},{"parent":"5bf8fe5c3c71","children":[{"parent":"10c2d21c2e0f","children":[],"id":"87b0e8f5a418","title":"在默认条件下，当递归&nbsp;DOM&nbsp;节点的子元素时，React&nbsp;会同时遍历两个子元素的列表；当产生差异时，生成一个&nbsp;mutation"},{"parent":"10c2d21c2e0f","children":[],"id":"2a2a930e8f81","title":"在子元素列表末尾新增元素时，更变开销比较小"},{"parent":"10c2d21c2e0f","children":[],"id":"43e3cf0e4ff5","title":"如果简单实现的话，那么在列表头部插入会很影响性能，那么更变开销会比较大"}],"style":{"background-color":"rgb(255, 255, 255)","border-radius":"20px","color":"rgb(242, 154, 102)","border-color":"rgb(242, 154, 102)","border-width":"2px","border-style":"solid"},"id":"10c2d21c2e0f","title":"对子节点进行递归","icons":[{"color":"rgb(255, 159, 26)","name":"priority","index":"3","text":"&#xe635"}]},{"parent":"5bf8fe5c3c71","children":[{"parent":"371b4aeef5cd","children":[],"id":"5c9369578ac6","title":"为了解决以上问题，React&nbsp;支持&nbsp;key&nbsp;属性。当子元素拥有&nbsp;key&nbsp;时，React&nbsp;使用&nbsp;key&nbsp;来匹配原有树上的子元素以及最新树上的子元素"},{"parent":"371b4aeef5cd","children":[],"id":"70947470a997","title":"现实场景中，产生一个&nbsp;key&nbsp;并不困难。你要展现的元素可能已经有了一个唯一&nbsp;ID，于是&nbsp;key&nbsp;可以直接从你的数据中提取<br>"},{"parent":"371b4aeef5cd","children":[],"id":"be5a66609114","title":"当以上情况不成立时，你可以新增一个&nbsp;ID&nbsp;字段到你的模型中，<br>或者利用一部分内容作为哈希值来生成一个&nbsp;key。这个&nbsp;key&nbsp;不需要全局唯一，但在列表中需要保持唯一"}],"style":{"background-color":"rgb(255, 255, 255)","border-radius":"20px","color":"rgb(242, 154, 102)","border-color":"rgb(242, 154, 102)","border-width":"2px","border-style":"solid"},"id":"371b4aeef5cd","title":"Keys<br>","icons":[{"color":"rgb(48, 191, 191)","name":"priority","index":"4","text":"&#xe626"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","font-style":"normal","border-radius":"5px","background-color":"#FFCDD2","lineStype":{"lineColor":"#FFCDD2","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#FFCDD2","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"font-family":"微软雅黑","border-width":"0px","border-style":"none"},"id":"5bf8fe5c3c71","title":"Diffing&nbsp;算法<br>"},{"parent":"root","lineStyle":{"lineColor":"#C8E6C9","lineWidth":"2"},"children":[{"parent":"a01eafed5bb9","note":"","children":[],"id":"15028f67c0e5","title":"请谨记协调算法是一个实现细节。React&nbsp;可以在每个&nbsp;action&nbsp;之后对整个应用进行重新渲染，得到的最终结果也会是一样的。在此情境下，重新渲染表示在所有组件内调用&nbsp;render&nbsp;方法，这不代表&nbsp;React&nbsp;会卸载或装载它们。React&nbsp;只会基于以上提到的规则来决定如何进行差异的合并","icons":[{"color":"rgb(191, 30, 27)","name":"priority","index":"0","text":"&#xe67a"}]},{"parent":"a01eafed5bb9","children":[],"id":"412c765359ca","title":"我们定期探索优化算法，让常见用例更高效地执行。在当前的实现中，可以理解为一棵子树能在其兄弟之间移动，但不能移动到其他位置。在这种情况下，算法会重新渲染整棵子树<br>","icons":[{"color":"rgb(99, 171, 247)","name":"priority","index":"1","text":"&#xe625"}]},{"parent":"a01eafed5bb9","lineStyle":{"lineColor":"#555","lineWidth":1},"children":[{"parent":"793c480c9601","children":[],"id":"5a85b61d6ebb","title":"该算法不会尝试匹配不同组件类型的子树"},{"parent":"793c480c9601","children":[],"id":"5359aa048327","title":"Key&nbsp;应该具有稳定，可预测，以及列表内唯一的特质"}],"style":{"lineStype":{"lineColor":"#555","lineWidth":1},"padding":"2px 8px 2px 8px","color":"#666","lineStyle":{"lineColor":"#555","lineWidth":1},"textAlign":"left","font-weight":"normal","font-size":"13px","font-family":"微软雅黑","font-style":"normal"},"id":"793c480c9601","title":"由于&nbsp;React&nbsp;依赖探索的算法，<br>因此当以下假设没有得到满足，<br>性能会有所损耗","icons":[{"color":"rgb(113, 203, 45)","name":"priority","index":"2","text":"&#xe62a"}]}],"style":{"padding":"8px 10px 8px 10px","backgroundColor":"#2196F3","color":"#212121","textAlign":"left","font-weight":"bold","font-size":13,"border-color":"rgb(255, 255, 255)","font-style":"normal","border-radius":"5px","background-color":"#C8E6C9","lineStype":{"lineColor":"#F57F17","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"box-shadow":"1px 2px 6px #aaa","lineStyle":{"lineColor":"#C8E6C9","randomLineColor":"rgb(153,204,255)","lineWidth":"2"},"font-family":"微软雅黑","border-width":"0px","border-style":"none"},"id":"a01eafed5bb9","title":"权衡<br>"}],"root":true,"theme":"customise_7fd055efa78b","style":{"background-color":"#2196F3","border-radius":"6px","color":"rgb(255, 255, 255)","font-weight":"bold","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"root","title":"协调","icons":[],"structure":"mind_free"}},"meta":{"exportTime":"2022-04-08 12:35:08","member":"60cca488e0b34d55bbf2954f","diagramInfo":{"creator":"60cca488e0b34d55bbf2954f","created":"2022-04-08 11:38:52","modified":"2022-04-08 12:33:19","title":"3.15协调","category":"mind_free"},"id":"624fae4c1e085332f333081b","type":"ProcessOn Schema File","version":"1.0"}}